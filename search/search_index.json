{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the online dcumentation for COMETS - Computation Of Microbial Ecosystems in Time and Space. COMETS is a software platform for performing computer simulations of spatially structured microbial communities. It is based on stoichiometric modeling of the genome-scale metabolic network of individual microbial species using dynamic flux balance analysis, and on a discrete approximation of diffusion. For more information, see Harcombe et al., Metabolic Resource Allocation in Individual Microbes Determines Ecosystem Interactions and Spatial Dynamics, Cell Reports, 2014 . COMETS is built and maintained by the Daniel Segre Lab at Boston University. COMETS is open-source software. If you are interested in contributing to the development of COMETS and would like to obtain a copy of the code, please contact us: comets@bu.edu","title":"Home"},{"location":"capabilities/","text":"The core of COMETS is the simulation of the growth of microbial populations by maximizing an objective reaction, usually biomass production, in an iterative way. An initial amount of biomass of one or more species (defined by their metaboli models) is seeded in an environment containing a list of specified nutrients. In each iteration, both the amount of biomass and the environment are updated using FBA predictions. Capabilities in space COMETS is capable of simulating microbial growth in a spatially structured environment. This is achieved by partitioning the simulation space (\"world\") in a \"grid\" of smaller spaces. Inside each space, growth is considered to be well-mixed. Both nutrients and biomass can then propagate to contiguous spaces as simulation proceeds. 2D and 3D simulation \"worlds\" In addition to well-mixed conditions, COMETS can simulate 2D and 3D spatially structured environments. This enables simulation of, for instance, growth of colonies on 2D surfaces such as a Petri dish, or 3D structures such as tumors, bacterial colonies in 3D matrix, etc. Diffusive and convective propagation of biomass in space In simulations with spatial structure, different modes of biomass propagation are implemented. The diffusive mode simulates the propagation of free swimming motile bacteria, while the convective mode simulates the propagation of bacteria by mutual pushing. The two modes of propagation can be combined. Substrate-dependent nutrient and biomass propagation The diffusivity of nutrients as well as the propagation properties of the biomass depend on the substrate properties such as agar density, cell substrate friction coefficient etc. Boundary conditions Two types of boundary conditions are implemented. Fixed value and fixed source or sink rate. Biological capabilities COMETS features many interesting biological capabilities to refine and improve the predictions of stoichiometric models, as well as to simulate different types of biologically realistic conditions. Lag-phases in microbial growth Lag-phases are modelled as simulated growth activation of the colonies. Continuous (chemostat) and batch growth modes In chemostat mode, the user controls the rate of replenishment of the nutrient. In batch mode, the user controls dilution and frequency. Simulation of multispecies communities Simulation of two or more species (up to hundreds) can be performed in both species overlapping or non-overlapping spatial distribution, or in well-mixed conditions. Parsimonious dFBA Usually, any metabolic model has multiple optimal solutions. One way to choose among them is to assume that the cell will minimize the total flux through the metabolic network. To achieve this, parsimonious FBA first optimizes the objective function, e.g. growth. Then, it performs a second optimization by fixing growth at the previously obtained optimal level and minimizing the total flux through the network. Cell death A simple model of cell death is implemented with each species assigned death rate. Neutral population drift The presence of demographic noise can result in random variations in the abundance of different species in a simulation. This is especially useful in the batch-growth mode, where dilution bottlenecks can have a significant impact on growing populations. Evolutionary processes Comets allows for evolutionary simulations, including random mutation and drift during simulations. Currently, the only mutations that are available are reaction deletions. Computational capabilities COMETS software is implemented in the JAVA language. Therefore, it is highly portable and independent on the operative system. COMETS offers the following simulation capabilities. Graphical User Interface (GUI) In addition to the command line, COMETS simulations can be run using a graphical user interface that includes visualization tools. Parallelized dFBA Runs in multi-CPU systems as multi-threaded process for greater computational performance. MATLAB toolbox A toolbox in MATLAB for modifying the input files for COMETS in a programmatic way. Python toolbox A toolbox in Python for modifying the input files for COMETS in a programmatic way.","title":"Capabilities"},{"location":"capabilities/#capabilities-in-space","text":"COMETS is capable of simulating microbial growth in a spatially structured environment. This is achieved by partitioning the simulation space (\"world\") in a \"grid\" of smaller spaces. Inside each space, growth is considered to be well-mixed. Both nutrients and biomass can then propagate to contiguous spaces as simulation proceeds. 2D and 3D simulation \"worlds\" In addition to well-mixed conditions, COMETS can simulate 2D and 3D spatially structured environments. This enables simulation of, for instance, growth of colonies on 2D surfaces such as a Petri dish, or 3D structures such as tumors, bacterial colonies in 3D matrix, etc. Diffusive and convective propagation of biomass in space In simulations with spatial structure, different modes of biomass propagation are implemented. The diffusive mode simulates the propagation of free swimming motile bacteria, while the convective mode simulates the propagation of bacteria by mutual pushing. The two modes of propagation can be combined. Substrate-dependent nutrient and biomass propagation The diffusivity of nutrients as well as the propagation properties of the biomass depend on the substrate properties such as agar density, cell substrate friction coefficient etc. Boundary conditions Two types of boundary conditions are implemented. Fixed value and fixed source or sink rate.","title":"Capabilities in space"},{"location":"capabilities/#biological-capabilities","text":"COMETS features many interesting biological capabilities to refine and improve the predictions of stoichiometric models, as well as to simulate different types of biologically realistic conditions. Lag-phases in microbial growth Lag-phases are modelled as simulated growth activation of the colonies. Continuous (chemostat) and batch growth modes In chemostat mode, the user controls the rate of replenishment of the nutrient. In batch mode, the user controls dilution and frequency. Simulation of multispecies communities Simulation of two or more species (up to hundreds) can be performed in both species overlapping or non-overlapping spatial distribution, or in well-mixed conditions. Parsimonious dFBA Usually, any metabolic model has multiple optimal solutions. One way to choose among them is to assume that the cell will minimize the total flux through the metabolic network. To achieve this, parsimonious FBA first optimizes the objective function, e.g. growth. Then, it performs a second optimization by fixing growth at the previously obtained optimal level and minimizing the total flux through the network. Cell death A simple model of cell death is implemented with each species assigned death rate. Neutral population drift The presence of demographic noise can result in random variations in the abundance of different species in a simulation. This is especially useful in the batch-growth mode, where dilution bottlenecks can have a significant impact on growing populations. Evolutionary processes Comets allows for evolutionary simulations, including random mutation and drift during simulations. Currently, the only mutations that are available are reaction deletions.","title":"Biological capabilities"},{"location":"capabilities/#computational-capabilities","text":"COMETS software is implemented in the JAVA language. Therefore, it is highly portable and independent on the operative system. COMETS offers the following simulation capabilities. Graphical User Interface (GUI) In addition to the command line, COMETS simulations can be run using a graphical user interface that includes visualization tools. Parallelized dFBA Runs in multi-CPU systems as multi-threaded process for greater computational performance. MATLAB toolbox A toolbox in MATLAB for modifying the input files for COMETS in a programmatic way. Python toolbox A toolbox in Python for modifying the input files for COMETS in a programmatic way.","title":"Computational capabilities"},{"location":"installation/","text":"Installation of COMETS There are two ways to install COMETS: using the COMETS installer or by unpacking the .tar.gz file. The easiest is to use the installer, especially recommended for individual use on a laptop or desktop. The installer can be downloaded from: https://comets.bu.edu The users are required to register, after which they can obtain the installer appropriate for their system. The installer guides the user through a standard GUI installation procedure that includes accepting the license agreement, choosing the directory where COMETS will be installed (the default directory is recommended), the option to create a desktop shortcut etc. The installer is available for the Windows, MacOS and Linux systems. In addition to the GUI installer, we provide the comets_x.x.x.tar.gz file for custom installation, typically on a Linux system. The file should be unpacked in the directory were COMETS will be installed with: $tar -xzvf comets_x.x.x.tar.gz ./ This will create the comets installation directory. In Unix systems (Linux or MacOS) the user also needs to specify the COMETS_HOME environment variable, which has to point to the comets installation folder. In Linux systems, this is done by adding the following line to the .bashrc file located in the home folder: export COMETS_HOME = \"/your/comets/installation/folder\" Installation of the COMETS MATLAB Toolbox The COMETS toolbox for MATLAB can be downloaded from https://github.com/segrelab/comets-toolbox. You may download the toolbox as an archive from the GitHub repository, or execute the following command from the command line (the folder ./comets-toolbox will be created in the working directory): git clone https://github.com/segrelab/comets-toolbox.git comets-toolbox A prerequisite to install the toolbox this way is to have installed git which can be found here: https://git-scm.com/. Once this folder has been created, run the following commands in MATLAB to add the toolbox and its subfolders to the MATLAB path: >> addpath(genpath(\"comets-toolbox\"),\"-end\"); >> savepath(); where comets-toolbox is the full path to the directory where the toolbox was installed. On a Windows system, for example, this path may be: C:\\Users\\username\\comets-toolbox where username is replaced with the specific one for the user. In addition, this toolbox requires the installation of the COBRA toolbox, available at https://opencobra.github.io/ 40. Many functions of the COMETS toolbox will not work before loading the COBRA toolbox using the initCobraToolbox() command. The detailed instructions for installing the COBRA toolbox can be found here: https://opencobra.github.io/cobratoolbox/stable/installation.html. A prerequisite to install the COBRA toolbox is to have installed git which can be found here: https://git-scm.com/. Once git is installed, the toolbox can be installed by running: git clone --depth=1 https://github.com/opencobra/cobratoolbox.git cobratoolbox Once this folder has been created, run the following commands in MATLAB to add the toolbox and its subfolders to the MATLAB path: >> addpath(genpath(\"cobratoolbox\"),\"-end\"); >> savepath(); where cobratoolbox is the full path to the directory where the toolbox was installed. On a Windows system, for example, this path may be: C:\\Users\\username\\cobratoolbox where username is replaced with the one specific for the user. COMETS Python toolbox (cometspy) The COMETS Python toolbox (cometspy) is available from the package manager PyPI cometspy using the pip command. To install, run: pip install cometspy","title":"Installation"},{"location":"installation/#installation-of-comets","text":"There are two ways to install COMETS: using the COMETS installer or by unpacking the .tar.gz file. The easiest is to use the installer, especially recommended for individual use on a laptop or desktop. The installer can be downloaded from: https://comets.bu.edu The users are required to register, after which they can obtain the installer appropriate for their system. The installer guides the user through a standard GUI installation procedure that includes accepting the license agreement, choosing the directory where COMETS will be installed (the default directory is recommended), the option to create a desktop shortcut etc. The installer is available for the Windows, MacOS and Linux systems. In addition to the GUI installer, we provide the comets_x.x.x.tar.gz file for custom installation, typically on a Linux system. The file should be unpacked in the directory were COMETS will be installed with: $tar -xzvf comets_x.x.x.tar.gz ./ This will create the comets installation directory. In Unix systems (Linux or MacOS) the user also needs to specify the COMETS_HOME environment variable, which has to point to the comets installation folder. In Linux systems, this is done by adding the following line to the .bashrc file located in the home folder: export COMETS_HOME = \"/your/comets/installation/folder\"","title":"Installation of COMETS"},{"location":"installation/#installation-of-the-comets-matlab-toolbox","text":"The COMETS toolbox for MATLAB can be downloaded from https://github.com/segrelab/comets-toolbox. You may download the toolbox as an archive from the GitHub repository, or execute the following command from the command line (the folder ./comets-toolbox will be created in the working directory): git clone https://github.com/segrelab/comets-toolbox.git comets-toolbox A prerequisite to install the toolbox this way is to have installed git which can be found here: https://git-scm.com/. Once this folder has been created, run the following commands in MATLAB to add the toolbox and its subfolders to the MATLAB path: >> addpath(genpath(\"comets-toolbox\"),\"-end\"); >> savepath(); where comets-toolbox is the full path to the directory where the toolbox was installed. On a Windows system, for example, this path may be: C:\\Users\\username\\comets-toolbox where username is replaced with the specific one for the user. In addition, this toolbox requires the installation of the COBRA toolbox, available at https://opencobra.github.io/ 40. Many functions of the COMETS toolbox will not work before loading the COBRA toolbox using the initCobraToolbox() command. The detailed instructions for installing the COBRA toolbox can be found here: https://opencobra.github.io/cobratoolbox/stable/installation.html. A prerequisite to install the COBRA toolbox is to have installed git which can be found here: https://git-scm.com/. Once git is installed, the toolbox can be installed by running: git clone --depth=1 https://github.com/opencobra/cobratoolbox.git cobratoolbox Once this folder has been created, run the following commands in MATLAB to add the toolbox and its subfolders to the MATLAB path: >> addpath(genpath(\"cobratoolbox\"),\"-end\"); >> savepath(); where cobratoolbox is the full path to the directory where the toolbox was installed. On a Windows system, for example, this path may be: C:\\Users\\username\\cobratoolbox where username is replaced with the one specific for the user.","title":"Installation of the COMETS MATLAB Toolbox"},{"location":"installation/#comets-python-toolbox-cometspy","text":"The COMETS Python toolbox (cometspy) is available from the package manager PyPI cometspy using the pip command. To install, run: pip install cometspy","title":"COMETS Python toolbox (cometspy)"},{"location":"python_module_backup/branching_colony/","text":"Modeling growth and propagation of bacterial colonies on flat surfaces: branching colony This is the exact same as the circular colony protocol notebook, except that a few parameters in the COMETS model have been changed to cause the colony to branch. import cobra import cobra.test # for the ijo1366 model import sys import numpy as np sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") import cometspy as c First, let's make a \"toy\" model, using functionality of cobrapy. It directly converts extracellular carbon to biomass. carbon = cobra.Metabolite(\"carbon\", compartment = \"e\") carbon_exch = cobra.Reaction(\"Carbon_exch\", lower_bound = -1., upper_bound = 1000.) carbon_exch.add_metabolites({carbon: -1.}) Biomass = cobra.Reaction(\"Biomass\", lower_bound = 0., upper_bound = 1000.) Biomass.add_metabolites({carbon: -1.}) toy = cobra.Model(\"toy\") toy.add_reactions([carbon_exch, Biomass]) toy.objective = \"Biomass\" toy.repair() We can test that the model runs by doing FBA in cobrapy. It should generate as much biomass as the lower bound on carbon_exch. print(toy.medium) print(toy.optimize().objective_value) {'Carbon_exch': 1.0} 1.0 We will now convert this into a COMETS model, set its initial biomass, and set the first set of convection parameters. These are the parameters needed to obtain a branching colony with this toy model. Note that the timestep has to be set very low for this form of biomass spread. grid_size = 30 toy_comets = c.model(toy) toy_comets.initial_pop = [int(grid_size / 2),int(grid_size / 2),1.0] toy_comets.open_exchanges() toy_comets.add_convection_parameters(packedDensity = 1.2, elasticModulus = 5.e-3, frictionConstant = 1.0, convDiffConstant = 0.0) toy_comets.add_noise_variance_parameter(20.) Note: for convection parameters to function, params.all_params['biomassMotionStyle'] = 'Convection 2D' must also be set We make sure that the COMETS model does not consider the biomass reaction an exchange. toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH\"] = False toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH_IND\"] = 0 toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\", \"LB\"] = 0 This simulation's layout will be of a single, centered colony on a 100x100 grid. carbon will be spread homogenously. ly = c.layout([toy_comets]) ly.grid = [grid_size, grid_size] ly.set_specific_metabolite(\"carbon\", 1.) The main parameter we need to set is biomassmotionstyle, which must be set to \"Convection 2D\". Then, to capture the spatial information, we'll also log biomass (instead of just total biomass). Finally, we'll also adjust a handful of other parameters. These are stored in the dictionary all_params. p = c.params() p.all_params[\"biomassMotionStyle\"] = \"Convection 2D\" p.all_params[\"writeBiomassLog\"] = True p.all_params[\"BiomassLogRate\"] = 500 p.all_params[\"maxCycles\"] = 20000 p.all_params[\"timeStep\"] = 0.00025 p.all_params[\"spaceWidth\"] = 1 p.all_params[\"maxSpaceBiomass\"] = 10 p.all_params[\"minSpaceBiomass\"] = 0.25e-10 p.all_params[\"allowCellOverlap\"] = True p.all_params[\"growthDiffRate\"] = 0 p.all_params[\"flowDiffRate\"] = 3e-9 p.all_params[\"exchangestyle\"] = \"Monod Style\" p.all_params[\"defaultKm\"] = 0.01 p.all_params[\"defaultHill\"] = 1 p.all_params[\"defaultVmax\"] = 100 Now we make a simulation object and run it. This can take awhile. sim = c.comets(ly, p) # this should all be removable once the installer is made with dependencies in a predictable location sim.set_classpath(\"concurrent\", \"/opt/colt/lib/concurrent.jar\") sim.set_classpath(\"colt\", \"/opt/colt/lib/colt.jar\") sim.set_classpath(\"lang3\", \"/opt/commons-lang3-3.9/commons-lang3-3.9.jar\") sim.set_classpath(\"jmatio\",\"/opt/jmatio/lib/jmatio.jar\") sim.set_classpath(\"math3\",\"/opt/commons-math3-3.6.1/commons-math3-3.6.1.jar\") sim.set_classpath(\"bin\",\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/jars/comets_2.10.0.jar\") sim.set_classpath(\"gurobi\",\"/opt/gurobi900/linux64/lib/gurobi.jar\") sim.set_classpath(\"jdistlib\", \"/opt/jdistlib-0.4.5-bin.jar\") sim.run(False) # use the argument delete_files = False to keep all COMETS-generated files Warning: java class libraries cannot be found These are the expected locations for dependencies: Dependency expected path __________ _____________ gurobi /opt/gurobi900/linux64/gurobi.jar junit /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/junit-4.12.jar hamcrest /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/hamcrest-core-1.3.jar jogl_all /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar gluegen_rt /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar gluegen /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen.jar gluegen_rt_natives /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar jogl_all_natives /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar jmatio /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/lib/jamtio.jar jmat /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/JMatIO-041212/lib/jmatio.jar concurrent /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/concurrent.jar colt /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/colt.jar lang3 /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-lang3-3.7/commons-lang3-3.7.jar math3 /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar bin /Dropbox/work_related/harcombe_lab/segre/comets/bin/bin/comets_evo.jar You have two options to fix this problem: 1. set each class path correctly by doing: comets.set_classpath(libraryname, path) e.g. comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar') note that versions dont always have to exactly match, but you're on your own if they don't 2. fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH look at the current comets.JAVA_CLASSPATH to see how this should look. Running COMETS simulation ... Done! Now let's plot the results. Note how we specify the axes, otherwise \"cycle\", \"x\", and \"y\" will be assumed to be state variables. What we see is that both species survive, because the LCTStex_KO cross-feeds galactose from the galE_KO, which uses the glucose piece of lactose. The metabolites, as is typical in a chemostat, are in very low concentrations once equilibrium is reached. im = sim.get_biomass_image('toy', 1500) from matplotlib import pyplot as plt import matplotlib.colors, matplotlib.cm my_cmap = matplotlib.cm.get_cmap(\"copper\") my_cmap.set_bad((0,0,0)) plt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap) <matplotlib.image.AxesImage at 0x7f966a6b3630> big_image = np.zeros((grid_size * 8, grid_size * 5)) im_cycles = np.arange(p.all_params[\"BiomassLogRate\"], p.all_params[\"maxCycles\"] + p.all_params[\"BiomassLogRate\"], p.all_params[\"BiomassLogRate\"]) for i, cycle in enumerate(im_cycles): big_image[(grid_size * int(i / 5)):(grid_size + grid_size * int(i / 5)),(grid_size * (i % 5)):(grid_size + grid_size * (i % 5))] = sim.get_biomass_image(\"toy\", cycle) plt.imshow(big_image, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)","title":"Branching colony"},{"location":"python_module_backup/branching_colony/#modeling-growth-and-propagation-of-bacterial-colonies-on-flat-surfaces-branching-colony","text":"This is the exact same as the circular colony protocol notebook, except that a few parameters in the COMETS model have been changed to cause the colony to branch. import cobra import cobra.test # for the ijo1366 model import sys import numpy as np sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") import cometspy as c First, let's make a \"toy\" model, using functionality of cobrapy. It directly converts extracellular carbon to biomass. carbon = cobra.Metabolite(\"carbon\", compartment = \"e\") carbon_exch = cobra.Reaction(\"Carbon_exch\", lower_bound = -1., upper_bound = 1000.) carbon_exch.add_metabolites({carbon: -1.}) Biomass = cobra.Reaction(\"Biomass\", lower_bound = 0., upper_bound = 1000.) Biomass.add_metabolites({carbon: -1.}) toy = cobra.Model(\"toy\") toy.add_reactions([carbon_exch, Biomass]) toy.objective = \"Biomass\" toy.repair() We can test that the model runs by doing FBA in cobrapy. It should generate as much biomass as the lower bound on carbon_exch. print(toy.medium) print(toy.optimize().objective_value) {'Carbon_exch': 1.0} 1.0 We will now convert this into a COMETS model, set its initial biomass, and set the first set of convection parameters. These are the parameters needed to obtain a branching colony with this toy model. Note that the timestep has to be set very low for this form of biomass spread. grid_size = 30 toy_comets = c.model(toy) toy_comets.initial_pop = [int(grid_size / 2),int(grid_size / 2),1.0] toy_comets.open_exchanges() toy_comets.add_convection_parameters(packedDensity = 1.2, elasticModulus = 5.e-3, frictionConstant = 1.0, convDiffConstant = 0.0) toy_comets.add_noise_variance_parameter(20.) Note: for convection parameters to function, params.all_params['biomassMotionStyle'] = 'Convection 2D' must also be set We make sure that the COMETS model does not consider the biomass reaction an exchange. toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH\"] = False toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH_IND\"] = 0 toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\", \"LB\"] = 0 This simulation's layout will be of a single, centered colony on a 100x100 grid. carbon will be spread homogenously. ly = c.layout([toy_comets]) ly.grid = [grid_size, grid_size] ly.set_specific_metabolite(\"carbon\", 1.) The main parameter we need to set is biomassmotionstyle, which must be set to \"Convection 2D\". Then, to capture the spatial information, we'll also log biomass (instead of just total biomass). Finally, we'll also adjust a handful of other parameters. These are stored in the dictionary all_params. p = c.params() p.all_params[\"biomassMotionStyle\"] = \"Convection 2D\" p.all_params[\"writeBiomassLog\"] = True p.all_params[\"BiomassLogRate\"] = 500 p.all_params[\"maxCycles\"] = 20000 p.all_params[\"timeStep\"] = 0.00025 p.all_params[\"spaceWidth\"] = 1 p.all_params[\"maxSpaceBiomass\"] = 10 p.all_params[\"minSpaceBiomass\"] = 0.25e-10 p.all_params[\"allowCellOverlap\"] = True p.all_params[\"growthDiffRate\"] = 0 p.all_params[\"flowDiffRate\"] = 3e-9 p.all_params[\"exchangestyle\"] = \"Monod Style\" p.all_params[\"defaultKm\"] = 0.01 p.all_params[\"defaultHill\"] = 1 p.all_params[\"defaultVmax\"] = 100 Now we make a simulation object and run it. This can take awhile. sim = c.comets(ly, p) # this should all be removable once the installer is made with dependencies in a predictable location sim.set_classpath(\"concurrent\", \"/opt/colt/lib/concurrent.jar\") sim.set_classpath(\"colt\", \"/opt/colt/lib/colt.jar\") sim.set_classpath(\"lang3\", \"/opt/commons-lang3-3.9/commons-lang3-3.9.jar\") sim.set_classpath(\"jmatio\",\"/opt/jmatio/lib/jmatio.jar\") sim.set_classpath(\"math3\",\"/opt/commons-math3-3.6.1/commons-math3-3.6.1.jar\") sim.set_classpath(\"bin\",\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/jars/comets_2.10.0.jar\") sim.set_classpath(\"gurobi\",\"/opt/gurobi900/linux64/lib/gurobi.jar\") sim.set_classpath(\"jdistlib\", \"/opt/jdistlib-0.4.5-bin.jar\") sim.run(False) # use the argument delete_files = False to keep all COMETS-generated files Warning: java class libraries cannot be found These are the expected locations for dependencies: Dependency expected path __________ _____________ gurobi /opt/gurobi900/linux64/gurobi.jar junit /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/junit-4.12.jar hamcrest /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/hamcrest-core-1.3.jar jogl_all /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar gluegen_rt /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar gluegen /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen.jar gluegen_rt_natives /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar jogl_all_natives /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar jmatio /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/lib/jamtio.jar jmat /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/JMatIO-041212/lib/jmatio.jar concurrent /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/concurrent.jar colt /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/colt.jar lang3 /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-lang3-3.7/commons-lang3-3.7.jar math3 /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar bin /Dropbox/work_related/harcombe_lab/segre/comets/bin/bin/comets_evo.jar You have two options to fix this problem: 1. set each class path correctly by doing: comets.set_classpath(libraryname, path) e.g. comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar') note that versions dont always have to exactly match, but you're on your own if they don't 2. fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH look at the current comets.JAVA_CLASSPATH to see how this should look. Running COMETS simulation ... Done! Now let's plot the results. Note how we specify the axes, otherwise \"cycle\", \"x\", and \"y\" will be assumed to be state variables. What we see is that both species survive, because the LCTStex_KO cross-feeds galactose from the galE_KO, which uses the glucose piece of lactose. The metabolites, as is typical in a chemostat, are in very low concentrations once equilibrium is reached. im = sim.get_biomass_image('toy', 1500) from matplotlib import pyplot as plt import matplotlib.colors, matplotlib.cm my_cmap = matplotlib.cm.get_cmap(\"copper\") my_cmap.set_bad((0,0,0)) plt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap) <matplotlib.image.AxesImage at 0x7f966a6b3630> big_image = np.zeros((grid_size * 8, grid_size * 5)) im_cycles = np.arange(p.all_params[\"BiomassLogRate\"], p.all_params[\"maxCycles\"] + p.all_params[\"BiomassLogRate\"], p.all_params[\"BiomassLogRate\"]) for i, cycle in enumerate(im_cycles): big_image[(grid_size * int(i / 5)):(grid_size + grid_size * int(i / 5)),(grid_size * (i % 5)):(grid_size + grid_size * (i % 5))] = sim.get_biomass_image(\"toy\", cycle) plt.imshow(big_image, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)","title":"Modeling growth and propagation of bacterial colonies on flat surfaces: branching colony"},{"location":"python_module_backup/chemostat/","text":"Simulating a chemostat and crossfeeding with COMETS COMETS provides the functionality to run simulations in a chemostat. Here, we use the python toolbox to generate a chemostat simulation in two ways. 1) by manually assigning all the \"parts,\" and 2) by using a helper function we've included. Here we are going to simulate a chemostat with lactose as the sole carbon resource and two strains of E. coli: one which is defiicient in the ability to uptake lactose, and one which is deficient in the ability to metabolize galactose. We will use the ijo1366 model provided as part of cobrapy. Let's first do the imports. import cobra import cobra.test # for the ijo1366 model import sys sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") import cometspy as c Now let's load the ijo1366 model, make a copy, and knockout the relevant reactions. Note that the first model had galE knocked out to prevent metabolism of galactose, which will cause galactose to be secreted during metabolism of lactose. The second model had a reaction knocked out instead of a gene, as lactose transport to the periplasm can be accomplished with multiple genes, and so it is simpler to juts knockout the reaction itself. E_no_galE = cobra.test.create_test_model(\"ecoli\") # this model will have galE KO'd E_no_LCTStex = E_no_galE.copy() # this model will have lactose uptake KO'd E_no_galE.genes.b0759.knock_out() E_no_LCTStex.reactions.LCTStex.knock_out() We can test that the knockouts perform as expected by trying to grow them in media containing lactose and galactose. We do this in cobrapy. medium = E_no_galE.medium medium[\"EX_glc__D_e\"] = 0. medium[\"EX_lcts_e\"] = 1. medium[\"EX_gal_e\"] = 1. print(medium) E_no_galE.medium = medium E_no_LCTStex.medium = medium # examine growth and uptake in the galE knockout shows galactose is excreted print(\"\\n\\nE_no_galE uptakes lactose and excrete galactose: \") E_no_galE.summary() {'EX_ca2_e': 1000.0, 'EX_cbl1_e': 0.01, 'EX_cl_e': 1000.0, 'EX_co2_e': 1000.0, 'EX_cobalt2_e': 1000.0, 'EX_cu2_e': 1000.0, 'EX_fe2_e': 1000.0, 'EX_fe3_e': 1000.0, 'EX_glc__D_e': 0.0, 'EX_h_e': 1000.0, 'EX_h2o_e': 1000.0, 'EX_k_e': 1000.0, 'EX_mg2_e': 1000.0, 'EX_mn2_e': 1000.0, 'EX_mobd_e': 1000.0, 'EX_na1_e': 1000.0, 'EX_nh4_e': 1000.0, 'EX_ni2_e': 1000.0, 'EX_o2_e': 1000.0, 'EX_pi_e': 1000.0, 'EX_sel_e': 1000.0, 'EX_slnt_e': 1000.0, 'EX_so4_e': 1000.0, 'EX_tungs_e': 1000.0, 'EX_zn2_e': 1000.0, 'EX_lcts_e': 1.0, 'EX_gal_e': 1.0} E_no_galE uptakes lactose and excrete galactose: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } IN_FLUXES OUT_FLUXES OBJECTIVES ID FLUX ID FLUX ID FLUX 0 o2_e 2.464303 h2o_e 4.131365 BIOMASS_Ec_iJO1366_core_53p95M 0.086479 1 lcts_e 1.000000 co2_e 2.450194 NaN NaN 2 nh4_e 0.934040 gal_e 1.000000 NaN NaN 3 fe2_e 0.795974 fe3_e 0.794585 NaN NaN 4 pi_e 0.083420 NaN NaN NaN NaN print(\"\\n\\nE_no_LCTStex uptakes galactose but not lactose: \") E_no_LCTStex.summary() E_no_LCTStex uptakes galactose but not lactose: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } IN_FLUXES OUT_FLUXES OBJECTIVES ID FLUX ID FLUX ID FLUX 0 o2_e 2.310433 h2o_e 4.749252 BIOMASS_Ec_iJO1366_core_53p95M 0.085442 1 gal_e 1.000000 co2_e 2.492757 NaN NaN 2 nh4_e 0.922840 h_e 0.785058 NaN NaN 3 pi_e 0.082420 NaN NaN NaN NaN Now that we are satisfied we have made our models correctly, we can setup a COMES simulation. Let's intend that the medium above is the reservoir medium (except that we will remove galactose first), and that the input rate and output rate are 10% per hour. Here, let's set dilution rate parameter, the initial population size (in gDW), and generate the COMETS models. Whenever we make COMETS models from COBRA models, we almost always want to set the exchange lower bounds to -1000 so that COMETS can alter these based upon media concentrations. Finally, right now both models have the same ID, which will confuse COMETS, so we must give them unique IDs. # chemostat parameters dilution_rate = 0.1 # / hr initial_pop = 1.e-3 # gDW # make COMETS models from the cobrapy models E_no_galE.id = \"galE_KO\" E_no_LCTStex.id = \"LCTStex_KO\" galE_comets = c.model(E_no_galE) galE_comets.initial_pop = [0,0,initial_pop] # x, y, gDW galE_comets.open_exchanges() lcts_comets = c.model(E_no_LCTStex) lcts_comets.initial_pop = [0,0,initial_pop] # x, y, gDW lcts_comets.open_exchanges() Now we are going to use the manual method for making a chemostat. Recall that cobrapy media are set using exchange reaction IDs, whereas COMETS media are set using metabolite ids. We can easily take care of this difference with a dictionary comprehension. Here we do that, then generate a layout, and add the media components to that layout. # setup layout by providing models layout = c.layout([galE_comets, lcts_comets]) # re-write media (while removing galactose) and add it to layout comets_media = {key[3:]: value for key, value in medium.items() if key != \"EX_gal_e\"} for key, value in comets_media.items(): layout.set_specific_metabolite(key, value) The input of fresh media from the reservoir into the simulation is done using media_refresh. Metabolites with a media_refresh value are replenished at the specified amount per-hour. Since we are diluting at 0.1 per hour, we multiply the reservoir concentration by this rate. for key, value in comets_media.items(): layout.set_specific_refresh(key, value * dilution_rate) The rest of the chemostat--the outflow--is setup in the parameters using metaboliteDilutionRate and deathRate. These should be set equal to the desired dilution rate. Here we generate a parameters object and set these values. params = c.params() params.set_param(\"deathRate\", dilution_rate) params.set_param(\"metaboliteDilutionRate\", dilution_rate) Let's also adjust a few other parameters. params.set_param(\"timeStep\", 0.1) # hours params.set_param(\"maxSpaceBiomass\", 10.) # gDW params.set_param(\"maxCycles\", 300) # duration of simulation in time steps Finally, let's keep track of two key metabolites: lactose and galactose. We do this using the specificMedia log, and choosing the metabolites with a comma-separated string with no spaces. params.set_param(\"writeSpecificMediaLog\", True) params.set_param(\"specificMediaLogRate\", 1) # time steps params.set_param(\"specificMedia\", \"lcts_e,gal_e\") # metabolites to track Now the chemostat aspects are setup using the layout and the parameters. Therefore, we can generate a COMETS simulation, run it, and then examine the biomass and metabolites. sim = c.comets(layout, params) sim.run() Warning: java class libraries cannot be found Running COMETS simulation ... Done! Now let's plot the results. Note how we specify the axes, otherwise \"cycle\", \"x\", and \"y\" will be assumed to be state variables. What we see is that both species survive, because the LCTStex_KO cross-feeds galactose from the galE_KO, which uses the glucose piece of lactose. The metabolites, as is typical in a chemostat, are in very low concentrations once equilibrium is reached. sim.total_biomass.plot(x = \"cycle\", logy = True) sim.specific_media.plot(x = \"cycle\",y = [\"lcts_e\",\"gal_e\"]) <matplotlib.axes._subplots.AxesSubplot at 0x7f468e670b70> The above code required setting chemostat parameters in multiple places. We offer this functionality so that researchers can create complex setups that may, for example, have different initial concentrations than reservoir concentrations, and different inflow rates than outflow rates. However, we expect most chemostat simulations will function like above, where a single dilution parameter dictates the behavior of the system. For this typical use-case, we have made a helper function in the utils subpackage which generates a layout and parameters objects with the correct setup. from cometspy.utils import chemostat chemostat([galE_comets, lcts_comets], comets_media, dilution_rate) # we can still adjust the parameters as desired. params.set_param(\"timeStep\", 0.1) # hours params.set_param(\"maxSpaceBiomass\", 10.) # gDW params.set_param(\"maxCycles\", 300) # duration of simulation in time steps params.set_param(\"writeSpecificMediaLog\", True) params.set_param(\"specificMediaLogRate\", 1) # time steps params.set_param(\"specificMedia\", \"lcts_e,gal_e\") # metabolites to track # then we make the simulation object and run as before sim = c.comets(layout, params) sim.run() sim.total_biomass.plot(x = \"cycle\", logy = True) Running COMETS simulation ... Done! <matplotlib.axes._subplots.AxesSubplot at 0x7f468e200c88>","title":"Chemostat"},{"location":"python_module_backup/circular_colony/","text":"Modeling growth and propagation of bacterial colonies on flat surfaces: circular colony This protocol replicates the main text protocol that simulates colony expansion via mechanical pushing among the growing cells. One of the characteristics of the implemented model is that it undergoes a transition in colony morphology depending on the value of the dense packing parameter. In this protocol, we will choose parameters that result in a round colony. In \"branching_colony,\" we will choose parameters that result in a branching colony. Additionally,we will show how to generate a simple metabolic model with a single nutrient and a single reaction of biomass growth from uptake of the nutrient. We will make the layout much smaller than in the paper, however, because it is much faster to run. import cobra import cobra.test # for the ijo1366 model import sys import numpy as np import cometspy as c First, let's make a \"toy\" model, using functionality of cobrapy. It directly converts extracellular carbon to biomass. carbon = cobra.Metabolite(\"carbon\", compartment = \"e\") carbon_exch = cobra.Reaction(\"Carbon_exch\", lower_bound = -1., upper_bound = 1000.) carbon_exch.add_metabolites({carbon: -1.}) Biomass = cobra.Reaction(\"Biomass\", lower_bound = 0., upper_bound = 1000.) Biomass.add_metabolites({carbon: -1.}) toy = cobra.Model(\"toy\") toy.add_reactions([carbon_exch, Biomass]) #toy.add_reactions([carbon_exch, carbon_transport, Biomass]) toy.objective = \"Biomass\" toy.repair() We can test that the model runs by doing FBA in cobrapy. It should generate as much biomass as the lower bound on carbon_exch. print(toy.medium) print(toy.optimize().objective_value) {'Carbon_exch': 1.0} 1.0 We will now convert this into a COMETS model, set its initial biomass, and set the first set of convection parameters. These are the parameters needed to obtain a circular colony with this toy model. Note that the timestep has to be set very low for this form of biomass spread. grid_size = 50 toy_comets = c.model(toy) toy_comets.initial_pop = [int(grid_size / 2),int(grid_size / 2),1.0] toy_comets.reactions.loc[toy_comets.reactions.EXCH, \"LB\"] = -1000 toy_comets.add_convection_parameters(packedDensity = 0.5, elasticModulus = 1.e-4, frictionConstant = 1.0, convDiffConstant = 0.0) toy_comets.add_noise_variance_parameter(20.) Note: for convection parameters to function, params.all_params['biomassMotionStyle'] = 'Convection 2D' must also be set We make sure that the COMETS model does not consider the biomass reaction an exchange. toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH\"] = False toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH_IND\"] = 0 toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\", \"LB\"] = 0 This simulation's layout will be of a single, centered colony on a 100x100 grid. carbon will be spread homogenously. ly = c.layout([toy_comets]) ly.grid = [grid_size, grid_size] ly.set_specific_metabolite(\"carbon\", 1.) The main parameter we need to set is biomassmotionstyle, which must be set to \"Convection 2D\". Then, to capture the spatial information, we'll also log biomass (instead of just total biomass). Finally, we'll also adjust a handful of other parameters. These are stored in the dictionary all_params. p = c.params() p.set_param(\"biomassMotionStyle\", \"Convection 2D\") p.set_param(\"writeBiomassLog\", True) p.set_param(\"BiomassLogRate\", 100) p.set_param(\"maxCycles\", 2000) p.set_param(\"timeStep\", 0.0005) p.set_param(\"spaceWidth\", 1) p.set_param(\"maxSpaceBiomass\", 10) p.set_param(\"minSpaceBiomass\", 0.25e-10) p.set_param(\"allowCellOverlap\", True) p.set_param(\"growthDiffRate\", 0) p.set_param(\"flowDiffRate\", 3e-9) p.set_param(\"exchangestyle\", \"Monod Style\") p.set_param(\"defaultKm\", 0.01) p.set_param(\"defaultHill\", 1) p.set_param(\"defaultVmax\", 100) Now we make a simulation object and run it. This can take awhile. sim = c.comets(ly, p) sim.run() # set delete_files = False to maintain all comets-generated files Running COMETS simulation ... Done! Now let's plot the results. we use the helper script \"get_biomass_image,\" which needs the name of the model and the timestep. Then we use matplotlib to display it. im = sim.get_biomass_image('toy', 2000) from matplotlib import pyplot as plt import matplotlib.colors, matplotlib.cm my_cmap = matplotlib.cm.get_cmap(\"copper\") my_cmap.set_bad((0,0,0)) plt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap) We can tile the time series in a simple loop. big_image = np.zeros((grid_size * 4, grid_size * 5)) im_cycles = np.arange(p.all_params[\"BiomassLogRate\"], p.all_params[\"maxCycles\"] + p.all_params[\"BiomassLogRate\"], p.all_params[\"BiomassLogRate\"]) for i, cycle in enumerate(im_cycles): big_image[(grid_size * int(i / 5)):(grid_size + grid_size * int(i / 5)),(grid_size * (i % 5)):(grid_size + grid_size * (i % 5))] = sim.get_biomass_image(\"toy\", cycle) plt.imshow(big_image, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)","title":"Circular colony"},{"location":"python_module_backup/circular_colony/#modeling-growth-and-propagation-of-bacterial-colonies-on-flat-surfaces-circular-colony","text":"This protocol replicates the main text protocol that simulates colony expansion via mechanical pushing among the growing cells. One of the characteristics of the implemented model is that it undergoes a transition in colony morphology depending on the value of the dense packing parameter. In this protocol, we will choose parameters that result in a round colony. In \"branching_colony,\" we will choose parameters that result in a branching colony. Additionally,we will show how to generate a simple metabolic model with a single nutrient and a single reaction of biomass growth from uptake of the nutrient. We will make the layout much smaller than in the paper, however, because it is much faster to run. import cobra import cobra.test # for the ijo1366 model import sys import numpy as np import cometspy as c First, let's make a \"toy\" model, using functionality of cobrapy. It directly converts extracellular carbon to biomass. carbon = cobra.Metabolite(\"carbon\", compartment = \"e\") carbon_exch = cobra.Reaction(\"Carbon_exch\", lower_bound = -1., upper_bound = 1000.) carbon_exch.add_metabolites({carbon: -1.}) Biomass = cobra.Reaction(\"Biomass\", lower_bound = 0., upper_bound = 1000.) Biomass.add_metabolites({carbon: -1.}) toy = cobra.Model(\"toy\") toy.add_reactions([carbon_exch, Biomass]) #toy.add_reactions([carbon_exch, carbon_transport, Biomass]) toy.objective = \"Biomass\" toy.repair() We can test that the model runs by doing FBA in cobrapy. It should generate as much biomass as the lower bound on carbon_exch. print(toy.medium) print(toy.optimize().objective_value) {'Carbon_exch': 1.0} 1.0 We will now convert this into a COMETS model, set its initial biomass, and set the first set of convection parameters. These are the parameters needed to obtain a circular colony with this toy model. Note that the timestep has to be set very low for this form of biomass spread. grid_size = 50 toy_comets = c.model(toy) toy_comets.initial_pop = [int(grid_size / 2),int(grid_size / 2),1.0] toy_comets.reactions.loc[toy_comets.reactions.EXCH, \"LB\"] = -1000 toy_comets.add_convection_parameters(packedDensity = 0.5, elasticModulus = 1.e-4, frictionConstant = 1.0, convDiffConstant = 0.0) toy_comets.add_noise_variance_parameter(20.) Note: for convection parameters to function, params.all_params['biomassMotionStyle'] = 'Convection 2D' must also be set We make sure that the COMETS model does not consider the biomass reaction an exchange. toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH\"] = False toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\",\"EXCH_IND\"] = 0 toy_comets.reactions.loc[toy_comets.reactions.REACTION_NAMES == \"Biomass\", \"LB\"] = 0 This simulation's layout will be of a single, centered colony on a 100x100 grid. carbon will be spread homogenously. ly = c.layout([toy_comets]) ly.grid = [grid_size, grid_size] ly.set_specific_metabolite(\"carbon\", 1.) The main parameter we need to set is biomassmotionstyle, which must be set to \"Convection 2D\". Then, to capture the spatial information, we'll also log biomass (instead of just total biomass). Finally, we'll also adjust a handful of other parameters. These are stored in the dictionary all_params. p = c.params() p.set_param(\"biomassMotionStyle\", \"Convection 2D\") p.set_param(\"writeBiomassLog\", True) p.set_param(\"BiomassLogRate\", 100) p.set_param(\"maxCycles\", 2000) p.set_param(\"timeStep\", 0.0005) p.set_param(\"spaceWidth\", 1) p.set_param(\"maxSpaceBiomass\", 10) p.set_param(\"minSpaceBiomass\", 0.25e-10) p.set_param(\"allowCellOverlap\", True) p.set_param(\"growthDiffRate\", 0) p.set_param(\"flowDiffRate\", 3e-9) p.set_param(\"exchangestyle\", \"Monod Style\") p.set_param(\"defaultKm\", 0.01) p.set_param(\"defaultHill\", 1) p.set_param(\"defaultVmax\", 100) Now we make a simulation object and run it. This can take awhile. sim = c.comets(ly, p) sim.run() # set delete_files = False to maintain all comets-generated files Running COMETS simulation ... Done! Now let's plot the results. we use the helper script \"get_biomass_image,\" which needs the name of the model and the timestep. Then we use matplotlib to display it. im = sim.get_biomass_image('toy', 2000) from matplotlib import pyplot as plt import matplotlib.colors, matplotlib.cm my_cmap = matplotlib.cm.get_cmap(\"copper\") my_cmap.set_bad((0,0,0)) plt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap) We can tile the time series in a simple loop. big_image = np.zeros((grid_size * 4, grid_size * 5)) im_cycles = np.arange(p.all_params[\"BiomassLogRate\"], p.all_params[\"maxCycles\"] + p.all_params[\"BiomassLogRate\"], p.all_params[\"BiomassLogRate\"]) for i, cycle in enumerate(im_cycles): big_image[(grid_size * int(i / 5)):(grid_size + grid_size * int(i / 5)),(grid_size * (i % 5)):(grid_size + grid_size * (i % 5))] = sim.get_biomass_image(\"toy\", cycle) plt.imshow(big_image, norm = matplotlib.colors.LogNorm(), cmap = my_cmap)","title":"Modeling growth and propagation of bacterial colonies on flat surfaces: circular colony"},{"location":"python_module_backup/citrate/","text":"Studying the evolution citrate utilization in the Long Term Evolution Experiment. We here demonstrate the use of COMETS to study the effect of specific mutations on population dynamics in the context of experimental evolution. To do this, we will use one of the most well known evolution experiments, the E. coli Long Term evolution experiment [cite]. After ~33,000 generations, a large population expansion was observed in one of the replicates (Ara-3) of the E. coli long term evolution experiment (Blount et al 2008). This population expansion is associated with two key mutations that together enable the evolution of strong aerobic citrate use (Cit++ phenotype). The first mutation (occuring roughly 31,000 generations) caused the aerobic expression of the citT transporter, producing a weak citrate growth phenotype (Cit+, Blount et al 2012). A subsequent mutation (occuring roughly 33,000 generations in) caused high-level, constitutive expression of dctA, a proton-driven dicarboxylic acid transporter (Quandt et al 2014). Because these two mutations introduce known reactions into the e.coli metabolic network we can simulate them using COMETS. This example simulation uses the same models, paramaters and reaction knockouts outlined in (Bajic et al 2018). First, create the layout and simulate the DM25 medium. import cometspy as c import matplotlib as plt import cobra.test import cobra import pandas as pd import numpy as np layout = c.layout() #Set up media to be DM25 layout.add_typical_trace_metabolites() layout.set_specific_metabolite('glc__D_e', 0.000139) layout.set_specific_metabolite('cit_e', 0.0017) building empty layout model models will need to be added with layout.add_model() Warning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models Warning: The added metabolite (cit_e) is notable to be taken up by any of the current models Now load the model and build the mutants. To show the compatibility with the COBRApy toolbox, we will load the model and perform the mutations using COBRA, and then pass these models as input to build COMETS models. Unlike the LTEE ancestral strain REL606 (and E. coli in general), which possess the necessary genes for citrate utilization but do not express them in aerobic conditions, iJO1366 is able utilize both citrate and succinate as these reactions are unbounded by default. Thus, the ancestral phenotype can be recreated by knocking out three reactions CITt7pp (citT), SUCCt2_2pp (dctA) and SUCCt2_3pp (dcuA or dcuB). # Load the E. coli iJO1366 model mod = cobra.test.create_test_model('ecoli') # Set exchange reaction lower bounds to -1000 to allow them being controlled by COMETS for i in mod.reactions: if 'EX_' in i.id: i.lower_bound =-1000.0 #now create the mutants mod.reactions.SUCCt2_3pp.upper_bound=0.0 CitTdctA = mod.copy() mod.reactions.SUCCt2_2pp.upper_bound =0.0 CitT = mod.copy() mod.reactions.CITt7pp.upper_bound =0.0 WT = mod.copy() WT.id= 'Ancestor' CitT.id = 'Cit+' CitTdctA.id = 'Cit++' # Generate comets models and set their initial population size p = c.model(WT) p.initial_pop = [0, 0, 3.9e-11] # We'll introduce genotypes 100 cells at a time to avoid the risk of them going extinct through drift p2 = c.model(CitT) p2.initial_pop = [0, 0, 0] # not present at start p3 = c.model(CitTdctA) p3.initial_pop = [0, 0, 0] # not present at start # Add the models to the simulation layout.add_model(p) layout.add_model(p2) layout.add_model(p3) Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Read LP format model from file /tmp/tmpj1e0_y3y.lp Reading time = 0.03 seconds : 1805 rows, 5166 columns, 20366 nonzeros Read LP format model from file /tmp/tmpikjkpd7n.lp Reading time = 0.02 seconds : 1805 rows, 5166 columns, 20366 nonzeros Read LP format model from file /tmp/tmpabof91tv.lp Reading time = 0.03 seconds : 1805 rows, 5166 columns, 20366 nonzeros Set the parameters for the simulation. We use 1 hr as the COMETS timestep to speed up the simulation. Shortening this to the more commonly used 0.1 hr does not substantially affect the final result, but it does significantly increase the time it takes this simulation to run. ### Setting paramaters for the simulation ### b_params = c.params() b_params.all_params['timeStep'] = 1.0 b_params.all_params['deathRate'] = 0.01 b_params.all_params['batchDilution'] =True b_params.all_params['dilTime'] =24 b_params.all_params['dilFactor'] =100 b_params.all_params['cellSize']= 3.9e-13 #Size of a single cell b_params.all_params['minSpaceBiomass'] = 3.8e-13 Perform the simulations. We will divide our simulation in three actual COMETS runs. We will start the simulation at generation 25000 and run for around 6000 generations. At roughly generation 31,000, we introduce the CitT genotype and run for around 2000 Generations. Finally, at roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generations. For each run, we will input the final biomass composition of the previous run. biomass of each store the biomass data in a separate dataframe that we will then join together for analysis. Running COMETS simulation ... Done! cycles_per_day = 24.0/b_params.all_params['timeStep'] # We'll start at Generation 25,000. and run for around 6000 generations batch_test = c.comets(layout, b_params) batch_test.parameters.all_params['maxCycles'] = int(900*cycles_per_day) batch_test.run() phase_1 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13), 'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(batch_test.total_biomass.cycle+1)/cycles_per_day + 25000}) # At roughly Generation 31,000 we introduce the CitT genotype and run for around 2000 Generations batch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))] batch_test.layout.models[1].initial_pop = [0, 0, 3.9e-11] batch_test.layout.build_initial_pop() batch_test.parameters.set_param('maxCycles', int(300*cycles_per_day)) batch_test.run() phase_2 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13), 'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_1.Generations)}) # At roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generationr batch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))] batch_test.layout.models[1].initial_pop = [0, 0, float(batch_test.total_biomass['Cit+'].tail(1))] batch_test.layout.models[2].initial_pop = [0, 0, 3.9e-11] batch_test.layout.build_initial_pop() batch_test.parameters.set_param('maxCycles', int(900*cycles_per_day)) batch_test.run() phase_3 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13), 'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_2.Generations) }) Running COMETS simulation ... Done! Running COMETS simulation ... Done! Group all the results from the three runs together and plot the stationary phase population size through time. #Remove the final timepoint from each phase phase_1.drop(phase_1.tail(1).index, inplace=True) phase_2.drop(phase_2.tail(1).index, inplace=True) phase_3.drop(phase_3.tail(1).index, inplace=True) final_df = pd.concat([phase_1,phase_2,phase_3]) final_df.reindex() final_df = final_df[np.round((final_df.Generations - 25000) % 6.67,3) == 6.67] fig = final_df.plot(x='Generations') fig.set_yscale(\"log\")","title":"Citrate"},{"location":"python_module_backup/citrate/#studying-the-evolution-citrate-utilization-in-the-long-term-evolution-experiment","text":"We here demonstrate the use of COMETS to study the effect of specific mutations on population dynamics in the context of experimental evolution. To do this, we will use one of the most well known evolution experiments, the E. coli Long Term evolution experiment [cite]. After ~33,000 generations, a large population expansion was observed in one of the replicates (Ara-3) of the E. coli long term evolution experiment (Blount et al 2008). This population expansion is associated with two key mutations that together enable the evolution of strong aerobic citrate use (Cit++ phenotype). The first mutation (occuring roughly 31,000 generations) caused the aerobic expression of the citT transporter, producing a weak citrate growth phenotype (Cit+, Blount et al 2012). A subsequent mutation (occuring roughly 33,000 generations in) caused high-level, constitutive expression of dctA, a proton-driven dicarboxylic acid transporter (Quandt et al 2014). Because these two mutations introduce known reactions into the e.coli metabolic network we can simulate them using COMETS. This example simulation uses the same models, paramaters and reaction knockouts outlined in (Bajic et al 2018). First, create the layout and simulate the DM25 medium. import cometspy as c import matplotlib as plt import cobra.test import cobra import pandas as pd import numpy as np layout = c.layout() #Set up media to be DM25 layout.add_typical_trace_metabolites() layout.set_specific_metabolite('glc__D_e', 0.000139) layout.set_specific_metabolite('cit_e', 0.0017) building empty layout model models will need to be added with layout.add_model() Warning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models Warning: The added metabolite (cit_e) is notable to be taken up by any of the current models Now load the model and build the mutants. To show the compatibility with the COBRApy toolbox, we will load the model and perform the mutations using COBRA, and then pass these models as input to build COMETS models. Unlike the LTEE ancestral strain REL606 (and E. coli in general), which possess the necessary genes for citrate utilization but do not express them in aerobic conditions, iJO1366 is able utilize both citrate and succinate as these reactions are unbounded by default. Thus, the ancestral phenotype can be recreated by knocking out three reactions CITt7pp (citT), SUCCt2_2pp (dctA) and SUCCt2_3pp (dcuA or dcuB). # Load the E. coli iJO1366 model mod = cobra.test.create_test_model('ecoli') # Set exchange reaction lower bounds to -1000 to allow them being controlled by COMETS for i in mod.reactions: if 'EX_' in i.id: i.lower_bound =-1000.0 #now create the mutants mod.reactions.SUCCt2_3pp.upper_bound=0.0 CitTdctA = mod.copy() mod.reactions.SUCCt2_2pp.upper_bound =0.0 CitT = mod.copy() mod.reactions.CITt7pp.upper_bound =0.0 WT = mod.copy() WT.id= 'Ancestor' CitT.id = 'Cit+' CitTdctA.id = 'Cit++' # Generate comets models and set their initial population size p = c.model(WT) p.initial_pop = [0, 0, 3.9e-11] # We'll introduce genotypes 100 cells at a time to avoid the risk of them going extinct through drift p2 = c.model(CitT) p2.initial_pop = [0, 0, 0] # not present at start p3 = c.model(CitTdctA) p3.initial_pop = [0, 0, 0] # not present at start # Add the models to the simulation layout.add_model(p) layout.add_model(p2) layout.add_model(p3) Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Read LP format model from file /tmp/tmpj1e0_y3y.lp Reading time = 0.03 seconds : 1805 rows, 5166 columns, 20366 nonzeros Read LP format model from file /tmp/tmpikjkpd7n.lp Reading time = 0.02 seconds : 1805 rows, 5166 columns, 20366 nonzeros Read LP format model from file /tmp/tmpabof91tv.lp Reading time = 0.03 seconds : 1805 rows, 5166 columns, 20366 nonzeros Set the parameters for the simulation. We use 1 hr as the COMETS timestep to speed up the simulation. Shortening this to the more commonly used 0.1 hr does not substantially affect the final result, but it does significantly increase the time it takes this simulation to run. ### Setting paramaters for the simulation ### b_params = c.params() b_params.all_params['timeStep'] = 1.0 b_params.all_params['deathRate'] = 0.01 b_params.all_params['batchDilution'] =True b_params.all_params['dilTime'] =24 b_params.all_params['dilFactor'] =100 b_params.all_params['cellSize']= 3.9e-13 #Size of a single cell b_params.all_params['minSpaceBiomass'] = 3.8e-13 Perform the simulations. We will divide our simulation in three actual COMETS runs. We will start the simulation at generation 25000 and run for around 6000 generations. At roughly generation 31,000, we introduce the CitT genotype and run for around 2000 Generations. Finally, at roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generations. For each run, we will input the final biomass composition of the previous run. biomass of each store the biomass data in a separate dataframe that we will then join together for analysis. Running COMETS simulation ... Done! cycles_per_day = 24.0/b_params.all_params['timeStep'] # We'll start at Generation 25,000. and run for around 6000 generations batch_test = c.comets(layout, b_params) batch_test.parameters.all_params['maxCycles'] = int(900*cycles_per_day) batch_test.run() phase_1 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13), 'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(batch_test.total_biomass.cycle+1)/cycles_per_day + 25000}) # At roughly Generation 31,000 we introduce the CitT genotype and run for around 2000 Generations batch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))] batch_test.layout.models[1].initial_pop = [0, 0, 3.9e-11] batch_test.layout.build_initial_pop() batch_test.parameters.set_param('maxCycles', int(300*cycles_per_day)) batch_test.run() phase_2 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13), 'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_1.Generations)}) # At roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generationr batch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))] batch_test.layout.models[1].initial_pop = [0, 0, float(batch_test.total_biomass['Cit+'].tail(1))] batch_test.layout.models[2].initial_pop = [0, 0, 3.9e-11] batch_test.layout.build_initial_pop() batch_test.parameters.set_param('maxCycles', int(900*cycles_per_day)) batch_test.run() phase_3 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13), 'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13), 'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13), 'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_2.Generations) }) Running COMETS simulation ... Done! Running COMETS simulation ... Done! Group all the results from the three runs together and plot the stationary phase population size through time. #Remove the final timepoint from each phase phase_1.drop(phase_1.tail(1).index, inplace=True) phase_2.drop(phase_2.tail(1).index, inplace=True) phase_3.drop(phase_3.tail(1).index, inplace=True) final_df = pd.concat([phase_1,phase_2,phase_3]) final_df.reindex() final_df = final_df[np.round((final_df.Generations - 25000) % 6.67,3) == 6.67] fig = final_df.plot(x='Generations') fig.set_yscale(\"log\")","title":"Studying the evolution citrate utilization in the Long Term Evolution Experiment."},{"location":"python_module_backup/competition_assay/","text":"Competition assay and competitive exclusion in serial transfers Competition experiments are frequently performed in the laboratory to assay, for example, the fitness of a mutant in competition to the wild-type. Here, we simulate one such experiemnt involving E. coli and a nonessential but deleterious mutation involving the deletion of the triose phosphate isomerase reaction from glycolisis. Load models and create a mutant We first load our E. coli \"core\" model and create the mutant in triose phosphate isomerase by setting both upper and lower bounds to zero. We will add both models to our test_tube layout. # Start by loading required packages, including the COMETS toolbox import cometspy as c import cobra.test import pandas as pd import matplotlib.pyplot as plt # load the models and perform the mutation wt = c.model(cobra.test.create_test_model(\"ecoli\")) wt.id = 'wt' mut = c.model(cobra.test.create_test_model(\"ecoli\")) mut.change_bounds('TPI', 0,0) mut.id = 'TPI_KO' # set its initial biomass, 5e-6 gr at coordinate [0,0] wt.initial_pop = [0, 0, 5e-8] mut.initial_pop = [0, 0, 5e-8] Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Create layout, add models and set up media composition We create an empty layout (\"test_tube\") and set the initial nutrient supply. # create an empty layout test_tube = c.layout() # add the models to the test tube test_tube.add_model(wt) test_tube.add_model(mut) building empty layout model models will need to be added with layout.add_model() Set the media composition by adding glucose and the inorganic nutrients required for this model (ammonia, phosphate) and oxygen. These inorganic nutrients will be considered as \"static\" by the simulation, with a value of 1000 that never depletes. Considering metabolites as \"static\" is the way COMETS has to simulate an unlimited supply of metabolites. # Add glucose to the media test_tube.set_specific_metabolite('glc__D_e', 0.01) # Add typical trace metabolites and oxygen coli as static trace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e', 'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e'] for i in trace_metabolites: test_tube.set_specific_metabolite(i, 1000) test_tube.set_specific_static(i, 1000) Set up simulation parameters We next create a parameters object and modify needed parameters - in this case only the number of cycles the simulation runs. comp_params = c.params() comp_params.set_param('maxCycles', 240) Run the simulation Finally, we create the comets object using the above created layout and parameters, and run the competition assay. comp_assay = c.comets(test_tube, comp_params) comp_assay.run() Running COMETS simulation ... Done! We now plot the biomasses of these two genotypes in coculture. biomass = comp_assay.total_biomass biomass['t'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep'] myplot = biomass.drop(columns=['cycle']).plot(x = 't') myplot.set_ylabel(\"Biomass (gr.)\") We can quantitatively analyze the results. For example, we can compute the competitive fitness of the mutant respect to the wild-type as the ratio of the biomass increase of the mutant divided by that of the wild-type: cfit = (biomass.loc[biomass['t'] == 24, 'TPI_KO'].iloc[0]/biomass.loc[biomass['t'] == 0, 'TPI_KO'].iloc[0])/(biomass.loc[biomass['t'] == 24, 'wt'].iloc[0]/biomass.loc[biomass['t'] == 0, 'wt'].iloc[0]) cfit 0.39378816074777145 Simulating serial transfers Using COMETS we can also simulate a serial tranfer competition between these two mutants. We will just modify the parameters, increasing the total simulation time and including batch transfers of 1% every 24h, but we will use the same test_tube layout as before. serial_params = c.params() serial_params.set_param('maxCycles', 240*25) # simulate 4 serial transfers of 24h each serial_params.set_param('batchDilution', True) serial_params.set_param('dilFactor', 0.01) serial_params.set_param('dilTime', 24) We run the simulation serial_expt = c.comets(test_tube, serial_params) serial_expt.JAVA_CLASSPATH = comp_assay.JAVA_CLASSPATH serial_expt.run() Running COMETS simulation ... Done! Now plot the biomass of the two species during the experiment biomass = serial_expt.total_biomass biomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24 myplot = biomass.drop(columns=['cycle']).plot(x = 'transfer') myplot.set_ylabel(\"Biomass (gr.)\")","title":"Competition assay"},{"location":"python_module_backup/competition_assay/#competition-assay-and-competitive-exclusion-in-serial-transfers","text":"Competition experiments are frequently performed in the laboratory to assay, for example, the fitness of a mutant in competition to the wild-type. Here, we simulate one such experiemnt involving E. coli and a nonessential but deleterious mutation involving the deletion of the triose phosphate isomerase reaction from glycolisis.","title":"Competition assay and competitive exclusion in serial transfers"},{"location":"python_module_backup/competition_assay/#load-models-and-create-a-mutant","text":"We first load our E. coli \"core\" model and create the mutant in triose phosphate isomerase by setting both upper and lower bounds to zero. We will add both models to our test_tube layout. # Start by loading required packages, including the COMETS toolbox import cometspy as c import cobra.test import pandas as pd import matplotlib.pyplot as plt # load the models and perform the mutation wt = c.model(cobra.test.create_test_model(\"ecoli\")) wt.id = 'wt' mut = c.model(cobra.test.create_test_model(\"ecoli\")) mut.change_bounds('TPI', 0,0) mut.id = 'TPI_KO' # set its initial biomass, 5e-6 gr at coordinate [0,0] wt.initial_pop = [0, 0, 5e-8] mut.initial_pop = [0, 0, 5e-8] Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only","title":"Load models and create a mutant"},{"location":"python_module_backup/competition_assay/#create-layout-add-models-and-set-up-media-composition","text":"We create an empty layout (\"test_tube\") and set the initial nutrient supply. # create an empty layout test_tube = c.layout() # add the models to the test tube test_tube.add_model(wt) test_tube.add_model(mut) building empty layout model models will need to be added with layout.add_model() Set the media composition by adding glucose and the inorganic nutrients required for this model (ammonia, phosphate) and oxygen. These inorganic nutrients will be considered as \"static\" by the simulation, with a value of 1000 that never depletes. Considering metabolites as \"static\" is the way COMETS has to simulate an unlimited supply of metabolites. # Add glucose to the media test_tube.set_specific_metabolite('glc__D_e', 0.01) # Add typical trace metabolites and oxygen coli as static trace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e', 'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e'] for i in trace_metabolites: test_tube.set_specific_metabolite(i, 1000) test_tube.set_specific_static(i, 1000)","title":"Create layout, add models and set up media composition"},{"location":"python_module_backup/competition_assay/#set-up-simulation-parameters","text":"We next create a parameters object and modify needed parameters - in this case only the number of cycles the simulation runs. comp_params = c.params() comp_params.set_param('maxCycles', 240)","title":"Set up simulation parameters"},{"location":"python_module_backup/competition_assay/#run-the-simulation","text":"Finally, we create the comets object using the above created layout and parameters, and run the competition assay. comp_assay = c.comets(test_tube, comp_params) comp_assay.run() Running COMETS simulation ... Done! We now plot the biomasses of these two genotypes in coculture. biomass = comp_assay.total_biomass biomass['t'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep'] myplot = biomass.drop(columns=['cycle']).plot(x = 't') myplot.set_ylabel(\"Biomass (gr.)\") We can quantitatively analyze the results. For example, we can compute the competitive fitness of the mutant respect to the wild-type as the ratio of the biomass increase of the mutant divided by that of the wild-type: cfit = (biomass.loc[biomass['t'] == 24, 'TPI_KO'].iloc[0]/biomass.loc[biomass['t'] == 0, 'TPI_KO'].iloc[0])/(biomass.loc[biomass['t'] == 24, 'wt'].iloc[0]/biomass.loc[biomass['t'] == 0, 'wt'].iloc[0]) cfit 0.39378816074777145","title":"Run the simulation"},{"location":"python_module_backup/competition_assay/#simulating-serial-transfers","text":"Using COMETS we can also simulate a serial tranfer competition between these two mutants. We will just modify the parameters, increasing the total simulation time and including batch transfers of 1% every 24h, but we will use the same test_tube layout as before. serial_params = c.params() serial_params.set_param('maxCycles', 240*25) # simulate 4 serial transfers of 24h each serial_params.set_param('batchDilution', True) serial_params.set_param('dilFactor', 0.01) serial_params.set_param('dilTime', 24) We run the simulation serial_expt = c.comets(test_tube, serial_params) serial_expt.JAVA_CLASSPATH = comp_assay.JAVA_CLASSPATH serial_expt.run() Running COMETS simulation ... Done! Now plot the biomass of the two species during the experiment biomass = serial_expt.total_biomass biomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24 myplot = biomass.drop(columns=['cycle']).plot(x = 'transfer') myplot.set_ylabel(\"Biomass (gr.)\")","title":"Simulating serial transfers"},{"location":"python_module_backup/demographic_noise_two_strains/","text":"Modeling growth and propagation of bacterial colonies on flat surfaces. This protocol replicates the main text protocol that simulates demographic noise which causes spatial segregation of expanding, equally-fit colonies. import cobra import cobra.test # for the ijo1366 model import sys import copy import numpy as np sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") # not necessary if you pip install cometspy import cometspy as c We will use the E. coli core model. ecoli = cobra.test.create_test_model(\"textbook\") We will now convert this into a COMETS model, and set two parameter options: the demographic noise parameter, which is called \"neutral drift,\" and convection-based motion parameters. grid_size = 40 ecoli_comets = c.model(ecoli) ecoli_comets.reactions.loc[ecoli_comets.reactions.EXCH, \"LB\"] = -1000 ecoli_comets.add_nonlinear_diffusion_parameters(convNonlinDiffZero = 0., convNonlinDiffN = 6.e-6, convNonlinDiffExponent = 1.0, convNonlinDiffHillN = 2., convNonlinDiffHillK = 0.001) ecoli_comets.add_neutral_drift_parameter(0.01) Note: for non-linear diffusion parameters to function, params.all_params['biomassMotionStyle'] = 'ConvNonlin' Diffusion 2D' must also be set Let's make an exact copy of the ecoli comets model. import random ecoli_comets2 = copy.copy(ecoli_comets) ecoli_comets2.id = \"e_coli_core2\" ecoli_comets.initial_pop = [[x, 0, np.random.normal(6.4e-5, 1e-6)] for x in range(grid_size)] ecoli_comets2.initial_pop = [[x, 0, np.random.normal(6.4e-5, 1e-6)] for x in range(grid_size)] This simulation will be of a single, centered colony on a 100x100 grid. carbon will be spread homogenously, and be fixed at initial concentration along one end. ly = c.layout([ecoli_comets, ecoli_comets2]) ly.grid = [grid_size, grid_size] ly.set_specific_metabolite(\"glc__D_e\", 2.2e-3) ly.set_specific_metabolite(\"h2o_e\", 1000) ly.set_specific_metabolite(\"nh4_e\", 1000) ly.set_specific_metabolite(\"o2_e\", 1000) ly.set_specific_metabolite(\"pi_e\", 1000) ly.set_specific_metabolite(\"h_e\", 1000) for x in range(grid_size): ly.set_specific_static_at_location(\"glc__D_e\", (x, grid_size-1), 1.1e-3) The main parameter we need to set is biomassmotionstyle, which must be set to \"ConvNonlin Diffusion 2D\". Then, to capture the spatial information, we'll also log biomass (instead of just total biomass). Finally, we'll also adjust a handful of other parameters. These are stored in the dictionary all_params. p = c.params() cycles = 1000 p.all_params[\"biomassMotionStyle\"] = \"ConvNonlin Diffusion 2D\" p.all_params[\"writeBiomassLog\"] = True p.all_params[\"BiomassLogRate\"] = cycles p.all_params[\"maxCycles\"] = cycles p.all_params[\"timeStep\"] = 0.05 p.all_params[\"spaceWidth\"] = 0.01 p.all_params[\"defaultDiffConst\"] = 6.e-6 p.all_params[\"maxSpaceBiomass\"] = 1000000 p.all_params[\"minSpaceBiomass\"] = 1.0e-9 p.all_params[\"allowCellOverlap\"] = True p.all_params[\"growthDiffRate\"] = 0 p.all_params[\"defaultVmax\"] = 18.5 p.all_params[\"defaultKm\"] = 0.000015 p.all_params[\"defaultHill\"] = 1 p.all_params[\"exchangestyle\"] = \"Monod Style\" Now we make a simulation object and run it. This can take awhile. sim = c.comets(ly, p) sim.run() Running COMETS simulation ... Done! Now let's plot the results. We use the get_biomass_image helper function and then matplotlib to do the plotting. im = sim.get_biomass_image('e_coli_core', cycles).astype(float) im = im / np.max(im) im2 = sim.get_biomass_image('e_coli_core2',cycles).astype(float) im2 = im2 / np.max(im2) final = np.zeros((grid_size,grid_size,3)) final[:,:,1] = im final[:,:,2] = im2 from matplotlib import pyplot as plt plt.imshow(final) <matplotlib.image.AxesImage at 0x7fba555da860>","title":"Demographic noise two strains"},{"location":"python_module_backup/evolution/","text":"Simulating evolution with COMETS COMETS is able to perform simulations that include the appearance of mutants containing reaction deletions and additions. In this small example, we will perform a serial transfer experiment starting with a clonal Escherichia coli population, and simulate the random appearance of reaction deletion mutants. We will then visualize the dynamics of all genotypes in time. Load the model We start by importing the necessary libraries and loading the E. coli model. import cometspy as c import cobra.test import os import pandas as pd import matplotlib.pyplot as plt # load model wt = cobra.test.create_test_model(\"ecoli\") Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Remove the bounds for all exchange reactions in the model to allow them to be controlled dynamically by COMETS # Remove bounds from exchange reactions for i in wt.reactions: if 'EX_' in i.id: i.lower_bound =-1000.0 Set up the layout We create a well mixed environment with a glucose minimal media. Here, we use the custom add_typical_trace_metabolites method to add trace metabolites (ions, metals etc) in unlimited amounts ( static flag). # generate layout test_tube = c.layout() test_tube.set_specific_metabolite('glc__D_e', 0.0001) test_tube.add_typical_trace_metabolites(amount=1000) # add model wt = c.model(wt) wt.initial_pop = [0, 0, 1e-7] test_tube.add_model(wt) building empty layout model models will need to be added with layout.add_model() Warning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models Set up simulation parameters Create a params object, and modify the needed parameters. The simulation in this example simulation consists of 10 days of experiment, with a 1:2 transfer every 3h. The mutation rate will be 10^{-7} 10^{-7} deletion events per reaction and generation. The cellSize parameter sets the amount of biomass that appears when a mutant occurs (i.e., one mutant cell appears). # .. load parameters and layout from file evo_params = c.params() evo_paramsset_param('timeStep', 0.1) # hours evo_paramsset_param('maxCycles', 2400) # simulate 10 serial transfers of 24h each (timeStep = 0.1) evo_paramsset_param('batchDilution', True) evo_paramsset_param('dilFactor', 0.5) # Dilution to apply evo_paramsset_param('dilTime', 3) # hours evo_paramsset_param('evolution', True) evo_paramsset_param('mutRate', 1e-8) # evo_paramsset_param('cellSize', 1e-10) # cellSize should always be larger than maxSpaceBiomass evo_paramsset_param('minSpaceBiomass', 1e-11) # make sure it is smaller than cell size! evo_paramsset_param('BiomassLogRate', 1) Run the simulation We now create the COMETS object using the above layout and parameters, and run the simulation. # create comets object from the loaded parameters and layout evo_simulation = c.comets(test_tube, evo_params) evo_simulation.JAVA_CLASSPATH = '/home/djordje/Dropbox/COMETS_RUN/lib/jmatio.jar:/home/djordje/Dropbox/COMETS_RUN/lib/jdistlib-0.4.5-bin.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.9.jar:/home/djordje/Dropbox/COMETS_RUN/lib/colt.jar:/home/djordje/Dropbox/COMETS_RUN/lib/concurrent.jar:/home/djordje/Dropbox/COMETS_RUN/bin/comets_2.9.3.jar:/opt/gurobi901/linux64/lib/gurobi.jar' # run comets simulation evo_simulation.run() Warning: java class libraries cannot be found These are the expected locations for dependencies: Dependency expected path __________ _____________ junit /home/djordje/Dropbox/COMETS_RUN/lib/junit/junit-4.12.jar hamcrest /home/djordje/Dropbox/COMETS_RUN/lib/junit/hamcrest-core-1.3.jar jogl_all /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar gluegen_rt /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar gluegen /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen.jar gluegen_rt_natives /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar jogl_all_natives /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar jmatio /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/lib/jamtio.jar jmat /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/JMatIO-041212/lib/jmatio.jar concurrent /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/concurrent.jar colt /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/colt.jar lang3 /home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.7/commons-lang3-3.7.jar math3 /home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar You have two options to fix this problem: 1. set each class path correctly by doing: comets.set_classpath(libraryname, path) e.g. comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar') note that versions dont always have to exactly match, but you're on your own if they don't 2. fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH look at the current comets.JAVA_CLASSPATH to see how this should look. Running COMETS simulation ... Done! Visualize the results We can visualize the population dynamics of all species over time (color coded) using standard Python plotting tools. fig, ax = plt.subplots(figsize=(15, 5)) for key, grp in evo_simulation.biomass.groupby(['species']): ax = grp.plot(ax=ax, kind='line', x='cycle', y='biomass') ax.get_legend().remove() plt.yscale('log') plt.ylabel(\"Biomass (gr.)\") Text(0,0.5,'Biomass (gr.)') In order to analyze the results, it is also helpful to visualize the genotypes data frame, which contains all the mutants that ever appeared during the simulation. The data frame contains three columns: The ancestor, the mutation, and the name of the resulting genotype, which is assigned as a random hash. evo_simulation.genotypes","title":"Evolution"},{"location":"python_module_backup/evolution/#simulating-evolution-with-comets","text":"COMETS is able to perform simulations that include the appearance of mutants containing reaction deletions and additions. In this small example, we will perform a serial transfer experiment starting with a clonal Escherichia coli population, and simulate the random appearance of reaction deletion mutants. We will then visualize the dynamics of all genotypes in time.","title":"Simulating evolution with COMETS"},{"location":"python_module_backup/evolution/#load-the-model","text":"We start by importing the necessary libraries and loading the E. coli model. import cometspy as c import cobra.test import os import pandas as pd import matplotlib.pyplot as plt # load model wt = cobra.test.create_test_model(\"ecoli\") Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Remove the bounds for all exchange reactions in the model to allow them to be controlled dynamically by COMETS # Remove bounds from exchange reactions for i in wt.reactions: if 'EX_' in i.id: i.lower_bound =-1000.0","title":"Load the model"},{"location":"python_module_backup/evolution/#set-up-the-layout","text":"We create a well mixed environment with a glucose minimal media. Here, we use the custom add_typical_trace_metabolites method to add trace metabolites (ions, metals etc) in unlimited amounts ( static flag). # generate layout test_tube = c.layout() test_tube.set_specific_metabolite('glc__D_e', 0.0001) test_tube.add_typical_trace_metabolites(amount=1000) # add model wt = c.model(wt) wt.initial_pop = [0, 0, 1e-7] test_tube.add_model(wt) building empty layout model models will need to be added with layout.add_model() Warning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models","title":"Set up the layout"},{"location":"python_module_backup/evolution/#set-up-simulation-parameters","text":"Create a params object, and modify the needed parameters. The simulation in this example simulation consists of 10 days of experiment, with a 1:2 transfer every 3h. The mutation rate will be 10^{-7} 10^{-7} deletion events per reaction and generation. The cellSize parameter sets the amount of biomass that appears when a mutant occurs (i.e., one mutant cell appears). # .. load parameters and layout from file evo_params = c.params() evo_paramsset_param('timeStep', 0.1) # hours evo_paramsset_param('maxCycles', 2400) # simulate 10 serial transfers of 24h each (timeStep = 0.1) evo_paramsset_param('batchDilution', True) evo_paramsset_param('dilFactor', 0.5) # Dilution to apply evo_paramsset_param('dilTime', 3) # hours evo_paramsset_param('evolution', True) evo_paramsset_param('mutRate', 1e-8) # evo_paramsset_param('cellSize', 1e-10) # cellSize should always be larger than maxSpaceBiomass evo_paramsset_param('minSpaceBiomass', 1e-11) # make sure it is smaller than cell size! evo_paramsset_param('BiomassLogRate', 1)","title":"Set up simulation parameters"},{"location":"python_module_backup/evolution/#run-the-simulation","text":"We now create the COMETS object using the above layout and parameters, and run the simulation. # create comets object from the loaded parameters and layout evo_simulation = c.comets(test_tube, evo_params) evo_simulation.JAVA_CLASSPATH = '/home/djordje/Dropbox/COMETS_RUN/lib/jmatio.jar:/home/djordje/Dropbox/COMETS_RUN/lib/jdistlib-0.4.5-bin.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.9.jar:/home/djordje/Dropbox/COMETS_RUN/lib/colt.jar:/home/djordje/Dropbox/COMETS_RUN/lib/concurrent.jar:/home/djordje/Dropbox/COMETS_RUN/bin/comets_2.9.3.jar:/opt/gurobi901/linux64/lib/gurobi.jar' # run comets simulation evo_simulation.run() Warning: java class libraries cannot be found These are the expected locations for dependencies: Dependency expected path __________ _____________ junit /home/djordje/Dropbox/COMETS_RUN/lib/junit/junit-4.12.jar hamcrest /home/djordje/Dropbox/COMETS_RUN/lib/junit/hamcrest-core-1.3.jar jogl_all /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar gluegen_rt /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar gluegen /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen.jar gluegen_rt_natives /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar jogl_all_natives /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar jmatio /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/lib/jamtio.jar jmat /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/JMatIO-041212/lib/jmatio.jar concurrent /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/concurrent.jar colt /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/colt.jar lang3 /home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.7/commons-lang3-3.7.jar math3 /home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar You have two options to fix this problem: 1. set each class path correctly by doing: comets.set_classpath(libraryname, path) e.g. comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar') note that versions dont always have to exactly match, but you're on your own if they don't 2. fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH look at the current comets.JAVA_CLASSPATH to see how this should look. Running COMETS simulation ... Done!","title":"Run the simulation"},{"location":"python_module_backup/evolution/#visualize-the-results","text":"We can visualize the population dynamics of all species over time (color coded) using standard Python plotting tools. fig, ax = plt.subplots(figsize=(15, 5)) for key, grp in evo_simulation.biomass.groupby(['species']): ax = grp.plot(ax=ax, kind='line', x='cycle', y='biomass') ax.get_legend().remove() plt.yscale('log') plt.ylabel(\"Biomass (gr.)\") Text(0,0.5,'Biomass (gr.)') In order to analyze the results, it is also helpful to visualize the genotypes data frame, which contains all the mutants that ever appeared during the simulation. The data frame contains three columns: The ancestor, the mutation, and the name of the resulting genotype, which is assigned as a random hash. evo_simulation.genotypes","title":"Visualize the results"},{"location":"python_module_backup/getting_started/","text":"The Comets Python Toolbox The Comets python module is intended to offer a programatic, easy and intuitive interface to COMETS . While it internally uses the same COMETS Java engine as always, it replaces the legacy parameter files, simulation layouts or models, bash scripts and output files, by python objects in a single environment, which users deal with to perform simulations and analyze the results. Any comets simulation starts from a layout and a set of parameters . The layout specifies the environment (media metabolites, refresh values, periodic dilutions) and the species present in it, that is, the models . The parameters specify many simulation characteristics, such as number of iterations, timestep, type of metabolite exchange or whether to record different output logs. Therefore, the two main types of objects are layout and params . These two are passed to the comets class, which perform simulations and contain their output. In this section, we will walk through the basic functionalities of COMETS using the Python Toolbox, and more specific examples of usage will be provided in the next sections. Preparing a model for COMETS The class model is used to store the genome-scale metabolic models used in COMETS simulations. Most frequently, we will first load a model using COBRAPy . Then, we can pass it to the COMETS model class, which allows us to change COMETS -specific model parameters, such as initial population sizes. import cobra import cobra.test import cometspy as c # Load a textbook example model using the COBRAPy toolbox test_model = cobra.test.create_test_model('textbook') # Use the above model to create a COMETS model test_model = c.model(test_model) # Change comets specific parameters, e.g. the initial biomass of the model # Notre test_model.initial_pop = [0, 0, 1e-7] Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Setting COMETS simulation parameters COMETS simulation parameters are stored in the params class, which contains just a dict object with the parameter names and values. If we initialize the class without arguments, it will contain the default parameter values (see here ). Once loaded, the parameter values can be visualized and modified as desired. # Create a parameters object with default values my_params = c.params() # Change the value of a parameter, for example number of simulation cycles my_params.set_param('maxCycles', 100) # Set some writeTotalBiomassLog parameter to True, in order to save the output my_params.set_param('writeTotalBiomassLog', True) # See avaliable parameters and their values my_params.show_params() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } VALUE UNITS BiomassLogName biomass.txt BiomassLogRate 1 cycles FluxLogName flux_out FluxLogRate 5 cycles MediaLogName media_out ... ... ... writeBiomassLog False logical writeFluxLog False logical writeMediaLog False logical writeSpecificMediaLog False logical writeTotalBiomassLog True logical 62 rows \u00d7 2 columns Preparing a COMETS simulation layout The layout class describes the characteristics of the environment, i.e. the \"world\", including which species (models) are in it. It can be instantiated in empty or using COMETS models: If instantiated without arguments (as my_layout = c.layout() ), an empty layout is created with all necessary fields that have to be populated. If a layout is instantiated passing a model (or several models), it will generate a layout with all metabolites those models can exchange with the environment at zero concentration, plus metals and ions at unlimited concentration (default -1000). To examine the different parts of a Comets layout , let\\'s first create one from the above loaded textbook model: my_layout = c.layout(test_model) The layout stores information about the species ( my_layout.models ) and spatial structure ( my_layout.grid ) in the environment. In this case, the model is only the textbook one, and the grid is the default one, which is 1 \\times 1 1 \\times 1 i.e. only one cell. The layout stores also information about the media as a pandas dataframe. In this case, no amount of any media component is present. my_layout.media .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } diff_c g_refresh g_static g_static_val init_amount metabolite 0 0.000005 0 0 0 0 ac_e 1 0.000005 0 0 0 0 acald_e 2 0.000005 0 0 0 0 akg_e 3 0.000005 0 0 0 0 co2_e 4 0.000005 0 0 0 0 etoh_e 5 0.000005 0 0 0 0 for_e 6 0.000005 0 0 0 0 fru_e 7 0.000005 0 0 0 0 fum_e 8 0.000005 0 0 0 0 glc__D_e 9 0.000005 0 0 0 0 gln__L_e 10 0.000005 0 0 0 0 glu__L_e 11 0.000005 0 0 0 0 h2o_e 12 0.000005 0 0 0 0 h_e 13 0.000005 0 0 0 0 lac__D_e 14 0.000005 0 0 0 0 mal__L_e 15 0.000005 0 0 0 0 nh4_e 16 0.000005 0 0 0 0 o2_e 17 0.000005 0 0 0 0 pi_e 18 0.000005 0 0 0 0 pyr_e 19 0.000005 0 0 0 0 succ_e metabolite init_amount diff_c g_static g_static_val g_refresh_val ca2_e 1000 NaN 1 1000 0 cbl_e 1000 NaN 1 1000 0 cl_e 1000 NaN 1 1000 0 . . . . . . . . . . . . . . . . . . When initiated from models, the media compounds that can be in the environment are all those for which there is an exchange reaction in at least one of the models. The media, shown in the table above, is a pandas dataframe where several pieces of information are stored: init_amount is the initial amount to be added to each cell of the simulation grid (in mmol). diff_c indicates whether the molecule has a diffusion constant different than the default one (stored in ec_layout.global_diff ) g_static indicates whether the component should remain at a static value, i.e. without change due to consumption and other effects of the simulation. This is useful for example, for setting some nutrients as unlimited. g_static_val indicates at which value shouold the nutrient remain static, if the previous coulmn value is 1. g_refresh_val indicates the amount of the metabolite that should be added after each simulation cycle to each cell of the grid. In addition, we can set local static and refresh values, specific to a cell of the simulation grid. When a media component is static , this means that its concentration is returned in each cycle to the set static value. This is used when we want a media component to remain virtually unlimited during a simulation. When a media component has a refresh value, this means it will be replenished by adding the set amount at every simulation cycle. Local refresh values are stored in a list, my_layout.local_refresh , where each element of the list is itself a list with the form [ x y m1_r m2_r m3_r ... ] . The first two elements x and y represent the coordinates, and are followed by the refresh values for all metabolites, in the same order as in media . Local static values are stored in a similar way. Each element of the my_layout.local_static list is itself a list with the form [ x y m1_s m1_s_v m2_s m2_s_v ... ] . The difference here is that for each metabolite, there are two values, one defining whether the molecule is to be static at that coordinate ( m1_s , m2_s , ... ) and another with the value at which it should be kept ( m1_s_v , m2_s_v , ... ). Note that both local_refresh and local_static can be empty (the default), or contain only entries for the coordinates where there is at least one nonzero refresh or static value, respectively. Finally, the layout also contains information about the starting biomass of each model. This information is stored in the initial_pop list. Each component of initial_pop is itself a list with the format [x y biomass_1 biomass_2 ...] specifying the amount of biomass of each model in each coordinate. Running a COMETS simulation The comets class uses a layout object and a parameters object to run simulations and store the output. Running a comets simulation is pretty straightforward. We firstly define the comets object by passing it a layout and a params objects as arguments. Then, we run() the simulation: my_simulation = c.comets(my_layout, my_params) my_simulation.run() Running COMETS simulation ... Done! Checking simulation output and possible errors In the background, this command invokes the COMETS Java engine in a console, giving a standard output (stdout) and standard error (stderr) logs. Both can be acessed through the fields run_outputs and run_errors , respectively. print(my_simulation.run_output) -script running script file: /home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_script Current Java version: 11.0.7 Loading layout file '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_layout'... Found 1 model files! Loading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ... Loading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ... Academic license - for non-commercial use only Academic license - for non-commercial use only Done! Testing default parameters... Done! Optimizer status code = 5 (looks ok!) objective solution = 0.8739215069684305 Constructing world... Done! medialist ac_e acald_e akg_e co2_e etoh_e for_e fru_e fum_e glc__D_e gln__L_e glu__L_e h2o_e h_e lac__D_e mal__L_e nh4_e o2_e pi_e pyr_e succ_e Cycle 1 Total biomass: Model e_coli_core.cmd: 1.0E-7 Cycle 2 Total biomass: Model e_coli_core.cmd: 1.0E-7 ... Total time = 0.312s print(my_simulation.run_errors) STDERR empty. Accessing the results of the simulation The results of the successful simulation are stored in several fields in the comets object, depending on whether the parameters writeTotalBiomasslog , writeBiomassLog , writeFluxLog and writeMediaLog were set to True . The field total_biomass stores the total biomass (summed up over all coordinates) for each timepoint and species. The field biomass stores detailed biomass values for each timepoint, coordinate and species. The field media stores the composition of the media at each timepoint. The field fluxes stores the metabolic fluxes for each species, coordinate and timepoint. Additionally, specific comets modes will have additional output fields; for instance, if we run an evolution simulation, the field genotypes will store information about each species such as its ancestor and which mutation it suffered. All of the output files ae pandas dataframes which can be further analyzed or plotted using standard Python tools. my_simulation.total_biomass .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cycle e_coli_core 0 0.0 1.000000e-07 1 1.0 1.000000e-07 2 2.0 1.000000e-07 3 3.0 1.000000e-07 4 4.0 1.000000e-07 ... ... ... 96 96.0 1.000000e-07 97 97.0 1.000000e-07 98 98.0 1.000000e-07 99 99.0 1.000000e-07 100 100.0 1.000000e-07 101 rows \u00d7 2 columns","title":"The Comets Python Toolbox"},{"location":"python_module_backup/getting_started/#the-comets-python-toolbox","text":"The Comets python module is intended to offer a programatic, easy and intuitive interface to COMETS . While it internally uses the same COMETS Java engine as always, it replaces the legacy parameter files, simulation layouts or models, bash scripts and output files, by python objects in a single environment, which users deal with to perform simulations and analyze the results. Any comets simulation starts from a layout and a set of parameters . The layout specifies the environment (media metabolites, refresh values, periodic dilutions) and the species present in it, that is, the models . The parameters specify many simulation characteristics, such as number of iterations, timestep, type of metabolite exchange or whether to record different output logs. Therefore, the two main types of objects are layout and params . These two are passed to the comets class, which perform simulations and contain their output. In this section, we will walk through the basic functionalities of COMETS using the Python Toolbox, and more specific examples of usage will be provided in the next sections.","title":"The Comets Python Toolbox"},{"location":"python_module_backup/getting_started/#preparing-a-model-for-comets","text":"The class model is used to store the genome-scale metabolic models used in COMETS simulations. Most frequently, we will first load a model using COBRAPy . Then, we can pass it to the COMETS model class, which allows us to change COMETS -specific model parameters, such as initial population sizes. import cobra import cobra.test import cometspy as c # Load a textbook example model using the COBRAPy toolbox test_model = cobra.test.create_test_model('textbook') # Use the above model to create a COMETS model test_model = c.model(test_model) # Change comets specific parameters, e.g. the initial biomass of the model # Notre test_model.initial_pop = [0, 0, 1e-7] Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only","title":"Preparing a model for COMETS"},{"location":"python_module_backup/getting_started/#setting-comets-simulation-parameters","text":"COMETS simulation parameters are stored in the params class, which contains just a dict object with the parameter names and values. If we initialize the class without arguments, it will contain the default parameter values (see here ). Once loaded, the parameter values can be visualized and modified as desired. # Create a parameters object with default values my_params = c.params() # Change the value of a parameter, for example number of simulation cycles my_params.set_param('maxCycles', 100) # Set some writeTotalBiomassLog parameter to True, in order to save the output my_params.set_param('writeTotalBiomassLog', True) # See avaliable parameters and their values my_params.show_params() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } VALUE UNITS BiomassLogName biomass.txt BiomassLogRate 1 cycles FluxLogName flux_out FluxLogRate 5 cycles MediaLogName media_out ... ... ... writeBiomassLog False logical writeFluxLog False logical writeMediaLog False logical writeSpecificMediaLog False logical writeTotalBiomassLog True logical 62 rows \u00d7 2 columns","title":"Setting COMETS simulation parameters"},{"location":"python_module_backup/getting_started/#preparing-a-comets-simulation-layout","text":"The layout class describes the characteristics of the environment, i.e. the \"world\", including which species (models) are in it. It can be instantiated in empty or using COMETS models: If instantiated without arguments (as my_layout = c.layout() ), an empty layout is created with all necessary fields that have to be populated. If a layout is instantiated passing a model (or several models), it will generate a layout with all metabolites those models can exchange with the environment at zero concentration, plus metals and ions at unlimited concentration (default -1000). To examine the different parts of a Comets layout , let\\'s first create one from the above loaded textbook model: my_layout = c.layout(test_model) The layout stores information about the species ( my_layout.models ) and spatial structure ( my_layout.grid ) in the environment. In this case, the model is only the textbook one, and the grid is the default one, which is 1 \\times 1 1 \\times 1 i.e. only one cell. The layout stores also information about the media as a pandas dataframe. In this case, no amount of any media component is present. my_layout.media .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } diff_c g_refresh g_static g_static_val init_amount metabolite 0 0.000005 0 0 0 0 ac_e 1 0.000005 0 0 0 0 acald_e 2 0.000005 0 0 0 0 akg_e 3 0.000005 0 0 0 0 co2_e 4 0.000005 0 0 0 0 etoh_e 5 0.000005 0 0 0 0 for_e 6 0.000005 0 0 0 0 fru_e 7 0.000005 0 0 0 0 fum_e 8 0.000005 0 0 0 0 glc__D_e 9 0.000005 0 0 0 0 gln__L_e 10 0.000005 0 0 0 0 glu__L_e 11 0.000005 0 0 0 0 h2o_e 12 0.000005 0 0 0 0 h_e 13 0.000005 0 0 0 0 lac__D_e 14 0.000005 0 0 0 0 mal__L_e 15 0.000005 0 0 0 0 nh4_e 16 0.000005 0 0 0 0 o2_e 17 0.000005 0 0 0 0 pi_e 18 0.000005 0 0 0 0 pyr_e 19 0.000005 0 0 0 0 succ_e metabolite init_amount diff_c g_static g_static_val g_refresh_val ca2_e 1000 NaN 1 1000 0 cbl_e 1000 NaN 1 1000 0 cl_e 1000 NaN 1 1000 0 . . . . . . . . . . . . . . . . . . When initiated from models, the media compounds that can be in the environment are all those for which there is an exchange reaction in at least one of the models. The media, shown in the table above, is a pandas dataframe where several pieces of information are stored: init_amount is the initial amount to be added to each cell of the simulation grid (in mmol). diff_c indicates whether the molecule has a diffusion constant different than the default one (stored in ec_layout.global_diff ) g_static indicates whether the component should remain at a static value, i.e. without change due to consumption and other effects of the simulation. This is useful for example, for setting some nutrients as unlimited. g_static_val indicates at which value shouold the nutrient remain static, if the previous coulmn value is 1. g_refresh_val indicates the amount of the metabolite that should be added after each simulation cycle to each cell of the grid. In addition, we can set local static and refresh values, specific to a cell of the simulation grid. When a media component is static , this means that its concentration is returned in each cycle to the set static value. This is used when we want a media component to remain virtually unlimited during a simulation. When a media component has a refresh value, this means it will be replenished by adding the set amount at every simulation cycle. Local refresh values are stored in a list, my_layout.local_refresh , where each element of the list is itself a list with the form [ x y m1_r m2_r m3_r ... ] . The first two elements x and y represent the coordinates, and are followed by the refresh values for all metabolites, in the same order as in media . Local static values are stored in a similar way. Each element of the my_layout.local_static list is itself a list with the form [ x y m1_s m1_s_v m2_s m2_s_v ... ] . The difference here is that for each metabolite, there are two values, one defining whether the molecule is to be static at that coordinate ( m1_s , m2_s , ... ) and another with the value at which it should be kept ( m1_s_v , m2_s_v , ... ). Note that both local_refresh and local_static can be empty (the default), or contain only entries for the coordinates where there is at least one nonzero refresh or static value, respectively. Finally, the layout also contains information about the starting biomass of each model. This information is stored in the initial_pop list. Each component of initial_pop is itself a list with the format [x y biomass_1 biomass_2 ...] specifying the amount of biomass of each model in each coordinate.","title":"Preparing a COMETS simulation layout"},{"location":"python_module_backup/getting_started/#running-a-comets-simulation","text":"The comets class uses a layout object and a parameters object to run simulations and store the output. Running a comets simulation is pretty straightforward. We firstly define the comets object by passing it a layout and a params objects as arguments. Then, we run() the simulation: my_simulation = c.comets(my_layout, my_params) my_simulation.run() Running COMETS simulation ... Done!","title":"Running a COMETS simulation"},{"location":"python_module_backup/getting_started/#checking-simulation-output-and-possible-errors","text":"In the background, this command invokes the COMETS Java engine in a console, giving a standard output (stdout) and standard error (stderr) logs. Both can be acessed through the fields run_outputs and run_errors , respectively. print(my_simulation.run_output) -script running script file: /home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_script Current Java version: 11.0.7 Loading layout file '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_layout'... Found 1 model files! Loading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ... Loading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ... Academic license - for non-commercial use only Academic license - for non-commercial use only Done! Testing default parameters... Done! Optimizer status code = 5 (looks ok!) objective solution = 0.8739215069684305 Constructing world... Done! medialist ac_e acald_e akg_e co2_e etoh_e for_e fru_e fum_e glc__D_e gln__L_e glu__L_e h2o_e h_e lac__D_e mal__L_e nh4_e o2_e pi_e pyr_e succ_e Cycle 1 Total biomass: Model e_coli_core.cmd: 1.0E-7 Cycle 2 Total biomass: Model e_coli_core.cmd: 1.0E-7 ... Total time = 0.312s print(my_simulation.run_errors) STDERR empty.","title":"Checking simulation output and possible errors"},{"location":"python_module_backup/getting_started/#accessing-the-results-of-the-simulation","text":"The results of the successful simulation are stored in several fields in the comets object, depending on whether the parameters writeTotalBiomasslog , writeBiomassLog , writeFluxLog and writeMediaLog were set to True . The field total_biomass stores the total biomass (summed up over all coordinates) for each timepoint and species. The field biomass stores detailed biomass values for each timepoint, coordinate and species. The field media stores the composition of the media at each timepoint. The field fluxes stores the metabolic fluxes for each species, coordinate and timepoint. Additionally, specific comets modes will have additional output fields; for instance, if we run an evolution simulation, the field genotypes will store information about each species such as its ancestor and which mutation it suffered. All of the output files ae pandas dataframes which can be further analyzed or plotted using standard Python tools. my_simulation.total_biomass .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cycle e_coli_core 0 0.0 1.000000e-07 1 1.0 1.000000e-07 2 2.0 1.000000e-07 3 3.0 1.000000e-07 4 4.0 1.000000e-07 ... ... ... 96 96.0 1.000000e-07 97 97.0 1.000000e-07 98 98.0 1.000000e-07 99 99.0 1.000000e-07 100 100.0 1.000000e-07 101 rows \u00d7 2 columns","title":"Accessing the results of the simulation"},{"location":"python_module_backup/petri_dish/","text":"Virtual Petri Dish: Spatial simulations and anaylsis of growth, metabolites, and fluxes import cobra import cobra.test # for the e coli core model import sys import numpy as np sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") # not necessary if you pip install cometspy import cometspy as c from matplotlib import pyplot as plt We will use the E. coli core model, which is available in cobrapy. core = cobra.test.create_test_model(\"textbook\") We convert the core model into a COMETS model, open its lower exchange bounds (so that they are set by the environment), and set convection parameters to simulate pushing-expansion of the colony. Also, we will pick a number of locations where founder biomass will be deposited. ecoli = c.model(core) ecoli.open_exchanges() ecoli.add_convection_parameters(packedDensity = 0.022, elasticModulus = 1.e-10, frictionConstant = 1.0, convDiffConstant = 0.0) ecoli.add_noise_variance_parameter(100.) # ecoli.initial_pop = [[x, x, 1.e-6] for x in [10,20,30,40]] ecoli.initial_pop = [[140, 50, 1.e-6], [58, 162, 1.e-6], [28,55,1.e-6], [132, 78, 1.e-6], [85, 152, 1.e-6], [73, 123, 1.e-6], [34, 76, 1.e-6], [150, 45, 1.e-6], [120, 73, 1.e-6], [34, 138, 1.e-6], [44, 180, 1.e-6], [180, 150, 1.e-6], [165, 135, 1.e-6], [24, 38, 1.e-6], [44, 45, 1.e-6], [99, 108, 1.e-6], [95, 23, 1.e-6], [35, 101, 1.e-6], [25, 102, 1.e-6]] Note: for convection parameters to function, params.all_params['biomassMotionStyle'] = 'Convection 2D' must also be set One of the novel aspects of this Protocol is that the \"Petri dish\" is divided into two different spatial regions, each of which has different metabolite diffusion constants. A user must define a number of parameters to get this to work: the \"region map\" which is a 2d matrix of integers corresponding to the specific regions, and then the region-specific parameters. We will do these in turn. First, the region map. For this example we will use a simulation arena of 200x200 boxes. Half of the \"Petri dish\" will be one region, and the second half will be the other region. We will make an integer numpy array that describes this. Here, I will also plot the region map as an image, although this is not at all necessary. width = 200 grid_size = [width, width] # width boxes in each direction region_map = np.zeros(grid_size, dtype = int) # an integer array filled with zeros region_map[:] = 1 # first fill the whole map with 1s region_map[int(width/2):width,:] = 2 # next fill the bottom half with 2s # this code here is unnecessary, but useful to visualize your region map: plt.imshow(np.transpose(region_map)) The region_map looks correct: a square of 200x200 boxes divided into two regions. Let's make the base layout for the simulation and set this region map. Once done, we will set the region parameters. ly = c.layout([ecoli]) ly.grid = grid_size ly.set_region_map(region_map) The region-specific parameters include a metabolite diffusion constant for each metabolite and a single friction constant used for all metabolites, per region. For simplicity we will also use the same metabolite diffusion constant for each metabolite, per region. This will be 5e-6 (cm2/s) for region 1, and 5e-7 for region 2. The friction constant will be 1.0 for both regions. Since we are using the same number for each metabolite, we will just make a list that is as long as the number of metabolites in the simulation. num_mets = ly.media.shape[0] diffusion_constant_region1 = [5.e-6] * num_mets diffusion_constant_region2 = [5.e-7] * num_mets friction_constant = 1.0 We set these values by specifying the (integer) region and then passing the list of diffusion constants and the scalar friction constant. This must be done separately for each region. ly.set_region_parameters(1, diffusion_constant_region1, friction_constant) ly.set_region_parameters(2, diffusion_constant_region2, friction_constant) The media concentrations will be initially constant across the \"Petri dish.\" We will set these here. ly.set_specific_metabolite(\"glc__D_e\", 5.e-5) ly.set_specific_metabolite(\"h2o_e\", 1000.) ly.set_specific_metabolite(\"nh4_e\", 1000.) ly.set_specific_metabolite(\"h_e\", 1000.) ly.set_specific_metabolite(\"pi_e\", 1000.) ly.display_current_media() diff_c g_refresh g_static g_static_val init_amount metabolite 8 0.000005 0 0 0 5e-05 glc__D_e 11 0.000005 0 0 0 1000 h2o_e 12 0.000005 0 0 0 1000 h_e 15 0.000005 0 0 0 1000 nh4_e 17 0.000005 0 0 0 1000 pi_e We next set the relevant parameters. We must make sure to set 'biomassMotionStyle' to 'Convection 2D' or else biomass will not use the convection parameters set above. p = c.params() p.all_params[\"maxCycles\"] = 5000 p.all_params[\"biomassMotionStyle\"] = \"Convection 2D\" p.all_params[\"writeBiomassLog\"] = True p.all_params[\"BiomassLogRate\"] = p.all_params[\"maxCycles\"] p.all_params[\"defaultKm\"] = 0.01 p.all_params[\"defaultVmax\"] = 10 p.all_params[\"timeStep\"] = 0.01 p.all_params[\"spaceWidth\"] = 0.02 p.all_params[\"maxSpaceBiomass\"] = 10 p.all_params[\"minSpaceBiomass\"] = 1.e-10 p.all_params[\"allowCellOverlap\"] = True p.all_params[\"writeFluxLog\"] = True p.all_params[\"FluxLogRate\"] = p.all_params[\"maxCycles\"] p.all_params[\"writeMediaLog\"] = True p.all_params[\"MediaLogRate\"] = p.all_params[\"maxCycles\"] Now we make a simulation object and run it. This can take awhile. sim = c.comets(ly, p) sim.run() Running COMETS simulation ... Done! Next, in turn, we use three different helper functions get to biomass, a metabolite concentration, and flux value (growth rate, here) and plot them in 2D space. from matplotlib import pyplot as plt import matplotlib.colors, matplotlib.cm import copy my_cmap = matplotlib.cm.get_cmap(\"copper\") my_cmap.set_bad((0,0,0)) im = sim.get_biomass_image('e_coli_core', p.all_params[\"maxCycles\"]) plt.imshow(im, norm = matplotlib.colors.LogNorm(), cmap = my_cmap) # glucose plt.imshow(sim.get_metabolite_image(\"glc__D_e\", p.all_params['maxCycles']+1)) # growth rate im = sim.get_flux_image(\"e_coli_core\", \"Biomass_Ecoli_core\", p.all_params[\"maxCycles\"]) plt.imshow(im)","title":"Petri dish"},{"location":"python_module_backup/soil/","text":"Soil-air interface. Using the functionality of COMETS, one can design simulations which go beyond in silico corollaries of lab experiments to make predictions for environments mimicking natural ecosystems, which is a necessary step for understanding natural ecology from first principles. In this example, we consider a simulation of a soil environment. We use source-and-sink functions to model how a root provides organic acids to the environment while removing ammonia (Huang et al 2014 Botany). While we restrict the root functionality to a source/sink, one could use functionality demonstrated above, for example extracellular enzymes, to generate feedback loops between microbe-produced metabolites and root exudation. We use fixed metabolite concentrations to mimic the largely unchanging air interface above a root, which generates an oxygen gradient. Additionally, since soil is characterized by strong spatial structure with many impenetrable barriers that localized interactions (Nunan 2017), we place \u201crock\u201d barriers throughout the simulation area. A more complex simulation could use varying diffusion constants for metabolites, as described in a previous protocol (Virtual Petri Dish). Similarly, we use standard diffusion of biomass, but this could be changed to use pushing force or non-linear diffusion for a potentially increased realism. import cobra import cobra.test # for the ijo1366 model import sys import copy import numpy as np sys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/cometspy\") # not necessary if you pip install cometspy import cometspy as c For the strain models, we use three well-curated soil bacteria, Pseudomonas putida (model iJN747), Bacillus subtilis (model iYO844), and Methanosarcina barkeri (model iAF629), which are available in the BIGG database (King et al 2016). Also, upon loading, the biomass functions of these models had positive lower bounds, which we then set to zero. model_dir = \"./models\" # model location iJN = cobra.io.read_sbml_model(model_dir + '/iJN746.xml') iJN.reactions.get_by_id('BIOMASS_KT_TEMP').lower_bound = 0 iJN.reactions.get_by_id('BIOMASS_KT_TEMP').upper_bound = 1000 iAF = cobra.io.read_sbml_model(model_dir + '/iAF692.xml') iAF.reactions.get_by_id('BIOMASS_Mb_30').lower_bound = 0 iAF.reactions.get_by_id('BIOMASS_Mb_30').upper_bound = 1000 iYO = cobra.io.read_sbml_model(model_dir + '/iYO844.xml') iYO.reactions.get_by_id('BIOMASS_BS_10').lower_bound = 0 iYO.reactions.get_by_id('BIOMASS_BS_10').upper_bound = 1000 Next, we convert these into COMETS models. We also use some helper functions to a) ensure the COMETS model does not think \"sink\" reactions are exchange reactions (as they are unbalanced in Cobra models, and therefore appear similar to exchanges), and b) open all exchange reaction bounds, to make sure that COMETS is in control of the media composition. iJN_comets = c.model(iJN) iJN_comets.ensure_sinks_are_not_exchanges() iJN_comets.open_exchanges() iAF_comets = c.model(iAF) iAF_comets.ensure_sinks_are_not_exchanges() iAF_comets.open_exchanges() iYO_comets = c.model(iYO) iYO_comets.ensure_sinks_are_not_exchanges() iYO_comets.open_exchanges() Our simulated world will be a 100x100 box lattice. The left-hand side, where x = 0, will be the root. The top, where y = 0, will be the air. Therefore, the biomass and the rocks will be distributed everywhere else. To ensure that we don't attempt to place biomass where rocks are placed, we first determine the rock locations. Specifically, we will create 70 rocks which are impervious to any biomass or metabolite. These rocks will have an average size of 15 boxes. To pick these locations, we use the helper function grow_rocks, in the utils subpackage: from cometspy.utils import grow_rocks, pick_random_locations grid_size = 30 # 100 n_rocks = 50 # 70 rock_locs = grow_rocks(n = n_rocks, xrange = [1,grid_size-1],yrange = [1,grid_size-1],mean_size = 5) Each species will have biomass seeded at 60 different locations, with no overlap. We will use the helper function pick_random_locations for this, which is useful as it can take in a previously-generated list of tuples of x-y locations as \u201cforbidden\u201d locations, such as the rock locations. First we make a copy of the rock_locs so we don't accidentally alter it, and call this copy forbidden_locs. import copy forbidden_locs = copy.deepcopy(rock_locs) Next we pick the random locations for each species, adding these locations to the forbidden locs as we go so as to prevent overlap. founders_per_species = 20 # 60 iJN_locs = pick_random_locations(n = founders_per_species, xrange = [1,grid_size], yrange = [1,grid_size], forbidden_locs = forbidden_locs) forbidden_locs.extend(iJN_locs) iYO_locs = pick_random_locations(founders_per_species, [1,grid_size],[1,grid_size], forbidden_locs) forbidden_locs.extend(iYO_locs) iAF_locs = pick_random_locations(founders_per_species, [1,grid_size],[1,grid_size], forbidden_locs) forbidden_locs.extend(iAF_locs) If we wish to take a look at what locations were chosen, we can easily make an image with matplotlib: from matplotlib import pyplot as plt initial_image = np.zeros((grid_size,grid_size,3)) for rock in rock_locs: initial_image[rock[1]-1,rock[0]-1,0:3] = 0.5 for loc in iJN_locs: initial_image[loc[1]-1,loc[0]-1,0] = 1 for loc in iYO_locs: initial_image[loc[1]-1,loc[0]-1,1] = 1 for loc in iAF_locs: initial_image[loc[1]-1,loc[0]-1,2] = 1 plt.imshow(initial_image) Things look good so we continue by making the layout and setting the dimensions. Then, we add the rock barriers to the layout. layout = c.layout() layout.grid = [grid_size,grid_size] layout.add_barriers(rock_locs) building empty layout model models will need to be added with layout.add_model() We set the initial population for each species by using a python list comprehension. Note that locations are properties of the model. After setting initial populations, the models are finished, so we add them to the layout. iJN_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iJN_locs] iYO_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iYO_locs] iAF_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iAF_locs] layout.add_model(iJN_comets) layout.add_model(iYO_comets) layout.add_model(iAF_comets) We want some metabolites available initially. These include all the typical trace nutrients needed, so we start with the helper function. After that, however, we want oxygen to mostly diffuse from the air, so we set that value lower. We also add a few other trace metabolites homogeneously throughout the environment that were not added with the helper function. layout.add_typical_trace_metabolites() layout.set_specific_metabolite('o2_e',0.00001) layout.set_specific_metabolite('hco3_e',1000) layout.set_specific_metabolite('co2_e',1000) layout.set_specific_metabolite('h2_e',1000) layout.set_specific_metabolite('so3_e',1000) layout.set_specific_metabolite('nh4_e',0.000001) layout.set_specific_metabolite('glc__D_e',0.0000001) layout.set_specific_metabolite('meoh_e',0.00000001) layout.set_specific_metabolite('cys__L_e',0.0000001) layout.set_specific_metabolite('4abz_e',0.0000001) layout.set_specific_metabolite('nac_e',0.00000001) To make the air layer, we set static media, which keep that metabolite at a fixed value. We also set a static level of zero oxygen at the \"bottom,\" to mimic continuous downwards diffusion. In a similar fashion, we set a static sink of ammonium where the \u201croot\u201d is. # set static media of O2 and CO2 at the top and bottom-- the \"air\" and continuous loss of O2 downwards for x in range(grid_size): layout.set_specific_static_at_location('o2_e', (x,0), .0001) # top layout.set_specific_static_at_location('o2_e', (x,grid_size-1), 0.) # bottom layout.set_specific_static_at_location('co2_e', (x,0), .0001) for x in range(grid_size): layout.set_specific_static_at_location('nh4_e', (0,x), 0.0) In contrast to ammonia, which we assume is always entirely consumed by the root, we assume the root drips organic acids and methanol into the environment at fixed rate, so we use a refresh function. for x in range(grid_size): layout.set_specific_refresh_at_location('cit_e', (0,x), .000001) layout.set_specific_refresh_at_location('meoh_e', (0,x), .000001) layout.set_specific_refresh_at_location('succ_e', (0,x), .000001) We are now done prepping the models and the layout. Next we setup the simulation parameters. Note the positive death rate. params = c.params() params.set_param('timeStep', 0.1) params.set_param('maxCycles', 1000) params.set_param('maxSpaceBiomass', 10) params.set_param('deathRate', 0.0001) # die at rate of 1/10000 per hour params.set_param('writeBiomassLog', True) params.set_param('BiomassLogRate', 500) params.set_param('writeMediaLog', True) params.set_param('MediaLogRate', 500) params.set_param(\"writeFluxLog\", True) params.set_param(\"FluxLogRate\", 500) params.set_param('numRunThreads', 3) params.set_param('defaultKm', 0.000001) sim = c.comets(layout, params) sim.run() # give the argument False if you want to save all intermediate files Running COMETS simulation ... Done! Now we make a biomass image using the get_biomass_image helper function. We put these into a 3D numpy array to visualize with matplotlib. im = sim.get_biomass_image('iJN746', params.all_params['maxCycles']) im2 = sim.get_biomass_image('iYO844',params.all_params['maxCycles']) im3 = sim.get_biomass_image('iAF692',params.all_params['maxCycles']) final = np.zeros((grid_size,grid_size,3)) final[:,:,0] = im / np.max(im) final[:,:,1] = im2 / np.max(im2) final[:,:,2] = im3 / np.max(im3) for rock in rock_locs: final[rock[1]-1,rock[0]-1,0:3] = 0.5 from matplotlib import pyplot as plt plt.imshow(final) Below here, we show a handful of metabolites. plt.imshow(sim.get_metabolite_image(\"succ_e\",params.all_params['maxCycles']+1)) plt.imshow(sim.get_metabolite_image(\"ac_e\",params.all_params['maxCycles']+1)) plt.imshow(sim.get_metabolite_image(\"nh4_e\",params.all_params['maxCycles']+1))","title":"Soil"},{"location":"python_module_backup/test_tube/","text":"Growth in a test tube This simple example illustrates the basic workflow of COMETS, including how to build the simulation layout, to specify parameters, load the model and plot the data once the simulation is finished. The core of the COMETS methodology is the Dynamic Flux Balance Analysis algorithm (Madahevan et al 2002). One of the first successful simulations of the time dynamics of bacterial metabolism was the classical study of Escherichia coli batch culture by Varma and Palsson (1994). Here, we reproduce one of the results in that study, the anaerobic fermentation in minimal media with glucose as the only carbon source. We will simulate a test tube by setting a well-mixed virtual container with 1cm3 1cm3 of media, which we will inoculate with 5\\times10^{\u22126} 5\\times10^{\u22126} grams of E. coli biomass. We will set the initial composition of the substrate to 11mM of glucose and unlimited amounts of ammonia and phosphate. For the nutrient uptake, we will use standard Michaelis-Menten kinetics, using the experimentally measured Monod parameter for anaerobic uptake of glucose by E. coli. For this simple example, we use the rudimentary \"core\" model of E. coli (Orth et al. 2009), which can be downloaded from http://bigg.ucsd.edu/models/e_coli_core or loaded, as we do here, using a function built in CobraPy. This model represents an E. coli metabolism simplified to its core functions (glycolysis, tricarboxylic cycle, pentose phosphate shunt, etc). Loading the COMETS Python Toolbox We first import the COMETS Python toolbox, which will also load all the dependencies, such as CobraPy or pandas. import cometspy as c import cobra.test import matplotlib.pyplot as plt Creating a test tube We are now ready to create a \"layout\" for our simulation. By instantiating the class layout without arguments, we will create the default simulation layout, represents an empty, well mixed space (called \"cell\") with volume 1cm^3. We can then modify this layout according to our needs, in this case adding the media composition in the desired concentration. # Create empty 1x1 layout test_tube = c.layout() # Add 11mM glucose and remove o2 test_tube.set_specific_metabolite('glc__D_e', 0.011) test_tube.set_specific_metabolite('o2_e', 0) # Add the rest of nutrients unlimited (ammonia, phosphate, water and protons) test_tube.set_specific_metabolite('nh4_e',1000); test_tube.set_specific_metabolite('pi_e',1000); test_tube.set_specific_metabolite('h2o_e',1000); test_tube.set_specific_metabolite('h_e',1000); building empty layout model models will need to be added with layout.add_model() Warning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models Warning: The added metabolite (o2_e) is notable to be taken up by any of the current models Warning: The added metabolite (nh4_e) is notable to be taken up by any of the current models Warning: The added metabolite (pi_e) is notable to be taken up by any of the current models Warning: The added metabolite (h2o_e) is notable to be taken up by any of the current models Warning: The added metabolite (h_e) is notable to be taken up by any of the current models Loading a model Next, we have to load the model and add it to the layout (or \"inoculate it in our test tube\"). We will instantiate the comets model class using a loaded CobraPy model as input. Note that we remove the bounds on glucose import, which will be set dynamically by COMETS during the simulation according to the dynamically changing external glucose concentration. We will set the initial biomass of our model at 10^{-6} 10^{-6} grams. # create the model using CobraPy functionality e_coli_cobra = cobra.test.create_test_model('textbook') # use the loaded model to build a comets model e_coli = c.model(e_coli_cobra) # remove the bounds from glucose import (will be set dynamically by COMETS) e_coli.change_bounds('EX_glc__D_e', -1000, 1000) # set the model's initial biomass e_coli.initial_pop = [0, 0, 5e-6] # add it to the test_tube test_tube.add_model(e_coli) Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only Setting the simulation parameters We next instantiate the params class, which generates a set of parameters for the COMETS simulation with the [TODO LINK TO DEF VALS] default values for all of them. All of the parameters are contained in the all_params field which is a Python dict object, making it easy to change the value of the desired parameters. # Set the parameters that are different from the default sim_params = c.params() sim_params.set_param('defaultVmax', 18.5) sim_params.set_param('defaultKm', 0.000015) sim_params.set_param('maxCycles', 1000) sim_params.set_param('timeStep', 0.01) sim_params.set_param('spaceWidth', 1) sim_params.set_param('maxSpaceBiomass', 10) sim_params.set_param('minSpaceBiomass', 1e-11) sim_params.set_param('writeMediaLog', True) Running the simulation With all set up, we can now instantiate the comets class by passing the layout (containing the model) and the params objects we just created. experiment = c.comets(test_tube, sim_params) Finally, we can run the simulation as: experiment.run() Running COMETS simulation ... Done! Analyzing the results The results of our simulation are stored in several pandas data frames contained in the comets object that we just simulated. The growth of the simulated model can be seen by plotting the total_biomass field. ax = experiment.total_biomass.plot(x = 'cycle') ax.set_ylabel(\"Biomass (gr.)\") Similarly, we can plot composition of the media. In this case, we will limit the plot to those components that are not added to the layout in unlimited amounts (\u201cstatic\u201d compounds, e.g. ammonia, phosphate, water, etc in this simulation). In this case, we do this by limiting the plot to compounds with concentration lower than 900mM. media = experiment.media.copy() media = media[media.conc_mmol<900] fig, ax = plt.subplots() media.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol') ax.legend(('acetate','ethanol', 'formate', 'glucose')) ax.set_ylabel(\"Concentration (mmol)\")","title":"Test tube"},{"location":"python_module_backup/test_tube/#growth-in-a-test-tube","text":"This simple example illustrates the basic workflow of COMETS, including how to build the simulation layout, to specify parameters, load the model and plot the data once the simulation is finished. The core of the COMETS methodology is the Dynamic Flux Balance Analysis algorithm (Madahevan et al 2002). One of the first successful simulations of the time dynamics of bacterial metabolism was the classical study of Escherichia coli batch culture by Varma and Palsson (1994). Here, we reproduce one of the results in that study, the anaerobic fermentation in minimal media with glucose as the only carbon source. We will simulate a test tube by setting a well-mixed virtual container with 1cm3 1cm3 of media, which we will inoculate with 5\\times10^{\u22126} 5\\times10^{\u22126} grams of E. coli biomass. We will set the initial composition of the substrate to 11mM of glucose and unlimited amounts of ammonia and phosphate. For the nutrient uptake, we will use standard Michaelis-Menten kinetics, using the experimentally measured Monod parameter for anaerobic uptake of glucose by E. coli. For this simple example, we use the rudimentary \"core\" model of E. coli (Orth et al. 2009), which can be downloaded from http://bigg.ucsd.edu/models/e_coli_core or loaded, as we do here, using a function built in CobraPy. This model represents an E. coli metabolism simplified to its core functions (glycolysis, tricarboxylic cycle, pentose phosphate shunt, etc).","title":"Growth in a test tube"},{"location":"python_module_backup/test_tube/#loading-the-comets-python-toolbox","text":"We first import the COMETS Python toolbox, which will also load all the dependencies, such as CobraPy or pandas. import cometspy as c import cobra.test import matplotlib.pyplot as plt","title":"Loading the COMETS Python Toolbox"},{"location":"python_module_backup/test_tube/#creating-a-test-tube","text":"We are now ready to create a \"layout\" for our simulation. By instantiating the class layout without arguments, we will create the default simulation layout, represents an empty, well mixed space (called \"cell\") with volume 1cm^3. We can then modify this layout according to our needs, in this case adding the media composition in the desired concentration. # Create empty 1x1 layout test_tube = c.layout() # Add 11mM glucose and remove o2 test_tube.set_specific_metabolite('glc__D_e', 0.011) test_tube.set_specific_metabolite('o2_e', 0) # Add the rest of nutrients unlimited (ammonia, phosphate, water and protons) test_tube.set_specific_metabolite('nh4_e',1000); test_tube.set_specific_metabolite('pi_e',1000); test_tube.set_specific_metabolite('h2o_e',1000); test_tube.set_specific_metabolite('h_e',1000); building empty layout model models will need to be added with layout.add_model() Warning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models Warning: The added metabolite (o2_e) is notable to be taken up by any of the current models Warning: The added metabolite (nh4_e) is notable to be taken up by any of the current models Warning: The added metabolite (pi_e) is notable to be taken up by any of the current models Warning: The added metabolite (h2o_e) is notable to be taken up by any of the current models Warning: The added metabolite (h_e) is notable to be taken up by any of the current models","title":"Creating a test tube"},{"location":"python_module_backup/test_tube/#loading-a-model","text":"Next, we have to load the model and add it to the layout (or \"inoculate it in our test tube\"). We will instantiate the comets model class using a loaded CobraPy model as input. Note that we remove the bounds on glucose import, which will be set dynamically by COMETS during the simulation according to the dynamically changing external glucose concentration. We will set the initial biomass of our model at 10^{-6} 10^{-6} grams. # create the model using CobraPy functionality e_coli_cobra = cobra.test.create_test_model('textbook') # use the loaded model to build a comets model e_coli = c.model(e_coli_cobra) # remove the bounds from glucose import (will be set dynamically by COMETS) e_coli.change_bounds('EX_glc__D_e', -1000, 1000) # set the model's initial biomass e_coli.initial_pop = [0, 0, 5e-6] # add it to the test_tube test_tube.add_model(e_coli) Using license file /home/djordje/gurobi.lic Academic license - for non-commercial use only","title":"Loading a model"},{"location":"python_module_backup/test_tube/#setting-the-simulation-parameters","text":"We next instantiate the params class, which generates a set of parameters for the COMETS simulation with the [TODO LINK TO DEF VALS] default values for all of them. All of the parameters are contained in the all_params field which is a Python dict object, making it easy to change the value of the desired parameters. # Set the parameters that are different from the default sim_params = c.params() sim_params.set_param('defaultVmax', 18.5) sim_params.set_param('defaultKm', 0.000015) sim_params.set_param('maxCycles', 1000) sim_params.set_param('timeStep', 0.01) sim_params.set_param('spaceWidth', 1) sim_params.set_param('maxSpaceBiomass', 10) sim_params.set_param('minSpaceBiomass', 1e-11) sim_params.set_param('writeMediaLog', True)","title":"Setting the simulation parameters"},{"location":"python_module_backup/test_tube/#running-the-simulation","text":"With all set up, we can now instantiate the comets class by passing the layout (containing the model) and the params objects we just created. experiment = c.comets(test_tube, sim_params) Finally, we can run the simulation as: experiment.run() Running COMETS simulation ... Done!","title":"Running the simulation"},{"location":"python_module_backup/test_tube/#analyzing-the-results","text":"The results of our simulation are stored in several pandas data frames contained in the comets object that we just simulated. The growth of the simulated model can be seen by plotting the total_biomass field. ax = experiment.total_biomass.plot(x = 'cycle') ax.set_ylabel(\"Biomass (gr.)\") Similarly, we can plot composition of the media. In this case, we will limit the plot to those components that are not added to the layout in unlimited amounts (\u201cstatic\u201d compounds, e.g. ammonia, phosphate, water, etc in this simulation). In this case, we do this by limiting the plot to compounds with concentration lower than 900mM. media = experiment.media.copy() media = media[media.conc_mmol<900] fig, ax = plt.subplots() media.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol') ax.legend(('acetate','ethanol', 'formate', 'glucose')) ax.set_ylabel(\"Concentration (mmol)\")","title":"Analyzing the results"}]}